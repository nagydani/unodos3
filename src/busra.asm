; SE Basic IV - A classic BASIC interpreter for the Z80.
; Copyright (c) 2017 Source Solutions, Inc.

;	This file is part of SE Basic IV.
;
;	SE Basic IV is free software: you can redistribute it and/or modify
;	it under the terms of the GNU General Public License as published by
;	the Free Software Foundation, either version 3 of the License, or
;	(at your option) any later version.
;
;	SE Basic IV is distributed in the hope that it will be useful,
;	but WITHOUT ANY WARRANTY; without even the implied warranty o;
;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;	GNU General Public License for more details.
;
;	You should have received a copy of the GNU General Public License
;	along with SE Basic IV. If not, see <http://www.gnu.org/licenses/>.

; This version of the source is compatible with Zeus, though it is not making
; much use of it. http://www.desdes.com/products/oldfiles;

	include "busra.inc";	// label definitions and X80 instruction set;

; Zeus has a compare binary mode where it will check the bytes being generated
; by a source against a reference binary. If you uncomment this next line it
; will compare the bytes generated by this source against the original ROM. If
; there are any errors they will be reported and displayed in the margin on the
; left with the original bytes shown in RED (as usual for the Zeus editor you
; can point at this column and use a mouse scroll wheel to zoom up and down to
; see all the cases)

; import_comparison "48.rom", $0000;

; If zoCheckORG is TRUE Zeus will warn you if any ORG statements actually move
; the PC. Useful if the ORG statements are marking entry points that need to be
; fixed, as they are in this ROM code.

	zoCheckORG = true; 		// Get Zeus to tell us if the ORG statements are
;							// moving the PC.

	zoWarnFlow = false;		// prevent pseudo op-codes triggering warnings.

org $0000;
_start:
	di;
	xor a;
	ld de, $ffff;
	jp start_new;

org $0008;
_error:
	ld hl, (ch_add);
	ld (x_ptr), hl;
	jr error_2;

org $0010;
_print_a:
	jp print_a_2;

	defb $ff, $ff, $ff, $ff, $ff;

org $0018;
_get_char:
	ld hl, (ch_add);
	ld a, (hl);

org $001c;
test_char:
	call skip_over;
	ret nc;

org $0020;
_next_char:
	call ch_add_plus_1;
	jr test_char;

	defb $ff, $ff, $ff;

org $0028;
_calc:
	jp calculate;

	defb $ff, $ff, $ff, $ff, $ff;

org $0030;
_bc_spaces:
	push bc;
	ld hl, (worksp);
	push hl;
	jp reserve;

org $0038;
_mask_int:
	push af;
	push hl;
	ld hl, (frames);
	inc hl;
	ld (frames), hl;
	ld a, h;
	or l;
	jr nz, key_int;
	inc (iy + _frames_h);

org $0048;
key_int:
	push bc;
	push de;
	call keyboard;
	pop de;
	pop bc;
	pop hl;
	pop af;
	ei;
	ret;

org $0053;
error_2:
	pop hl;
	ld l, (hl);

org $0055;
error_3:
	ld (iy + _err_nr), l;
	ld sp, (err_sp);
	jp set_stk;

	defb $ff, $ff, $ff, $ff, $ff, $ff, $ff;

org $0066;
reset:
	push af;
	push hl;
	ld hl, (nmiadd);
	ld a, h;
	or l;
	jr nz, no_reset;
	jp (hl);

org $0070;
no_reset:
	pop hl;
	pop af;
	retn;

org $0074;
ch_add_plus_1:
	ld hl, (ch_add);

org $0077;
temp_ptr1:
	inc hl;

org $0078;
temp_ptr2:
	ld (ch_add), hl;
	ld a, (hl);
	ret;

org $007d;
skip_over:
	cp '!';
	ret nc;
	cp ctrl_enter;
	ret z;
	cp ctrl_ink;
	ret c;
	cp ctrl_tab + 1;
	ccf;
	ret c;
	inc hl;
	cp ctrl_at;
	jr c, skips;
	inc hl;

org $0090;
skips:
	scf;
	ld (ch_add), hl;
	ret;

org $0095;
token_table:
	defb '?' + $80;
	defb "RN", 'D' + $80;
	defb "INKEY", '$' + $80;
	defb 'P', 'I' + $80;
	defb 'F', 'N' + $80;
	defb "POIN", 'T' + $80;
	defb "SCREEN", '$' + $80;
	defb "ATT", 'R' + $80;
	defb 'A', 'T' + $80;
	defb "TA", 'B' + $80;
	defb "VAL", '$' + $80;
	defb "COD", 'E' + $80;
	defb "VA", 'L' + $80;
	defb "LE", 'N' + $80;
	defb "SI", 'N' + $80;
	defb "CO", 'S' + $80;
	defb "TA", 'N' + $80;
	defb "AS", 'N' + $80;
	defb "AC", 'S' + $80;
	defb "AT", 'N' + $80;
	defb 'L', 'N' + $80;
	defb "EX", 'P' + $80;
	defb "IN", 'T' + $80;
	defb "SQ", 'R' + $80;
	defb "SG", 'N' + $80;
	defb "AB", 'S' + $80;
	defb "PEE", 'K' + $80;
	defb 'I', 'N' + $80;
	defb "US", 'R' + $80;
	defb "STR", '$' + $80;
	defb "CHR", '$' + $80;
	defb "NO", 'T' + $80;
	defb "BI", 'N' + $80;
	defb 'O', 'R' + $80;
	defb "AN", 'D' + $80;
	defb '<', '=' + $80;
	defb '>', '=' + $80;
	defb '<', '>' + $80;
	defb "LIN", 'E' + $80;
	defb "THE", 'N' + $80;
	defb 'T', 'O' + $80;
	defb "STE", 'P' + $80;
	defb "DEF F", 'N' + $80;
	defb "CA", 'T' + $80;
	defb "FORMA", 'T' + $80;
	defb "MOV", 'E' + $80;
	defb "ERAS", 'E' + $80;
	defb "OPEN ", '#' + $80;
	defb "CLOSE ", '#' + $80;
	defb "MERG", 'E' + $80;
	defb "VERIF", 'Y' + $80;
	defb "BEE", 'P' + $80;
	defb "CIRCL", 'E' + $80;
	defb "IN", 'K' + $80;
	defb "PAPE", 'R' + $80;
	defb "FLAS", 'H' + $80;
	defb "BRIGH", 'T' + $80;
	defb "INVERS", 'E' + $80;
	defb "OVE", 'R' + $80;
	defb "OU", 'T' + $80;
	defb "LPRIN", 'T' + $80;
	defb "LLIS", 'T' + $80;
	defb "STO", 'P' + $80;
	defb "REA", 'D' + $80;
	defb "DAT", 'A' + $80;
	defb "RESTOR", 'E' + $80;
	defb "NE", 'W' + $80;
	defb "BORDE", 'R' + $80;
	defb "CONTINU", 'E' + $80;
	defb "DI", 'M' + $80;
	defb "RE", 'M' + $80;
	defb "FO", 'R' + $80;
	defb "GO T", 'O' + $80;
	defb "GO SU", 'B' + $80;
	defb "INPU", 'T' + $80;
	defb "LOA", 'D' + $80;
	defb "LIS", 'T' + $80;
	defb "LE", 'T' + $80;
	defb "PAUS", 'E' + $80;
	defb "NEX", 'T' + $80;
	defb "POK", 'E' + $80;
	defb "PRIN", 'T' + $80;
	defb "PLO", 'T' + $80;
	defb "RU", 'N' + $80;
	defb "SAV", 'E' + $80;
	defb "RANDOMIZ", 'E' + $80;
	defb 'I', 'F' + $80;
	defb "CL", 'S' + $80;
	defb "DRA", 'W' + $80;
	defb "CLEA", 'R' + $80;
	defb "RETUR", 'N' + $80;
	defb "COP", 'Y' + $80;

org $0205;
kt_main:
	defb "BHY65TGVNJU74RFCMKI83EDX", ctrl_symbol;
	defb "LO92WSZ ", ctrl_enter, "P01QA";

org $022c;
kt_ext:
	defb tk_read, tk_bin, tk_lprint, tk_data, tk_tan, tk_sgn, tk_abs;
	defb tk_sqr, tk_code, tk_val, tk_len, tk_usr, tk_pi;
	defb tk_inkey_str, tk_peek, tk_tab, tk_sin, tk_int, tk_restore;
	defb tk_rnd, tk_chr_str, tk_llist, tk_cos, tk_exp, tk_str_str;
	defb tk_ln;

org $0246;
kt_ext_shft:
	defb '~', tk_bright, tk_paper, $5c, tk_atn, '{', '}', tk_circle;
	defb tk_in, tk_val_str, tk_screen_str, tk_attr, tk_inverse;
	defb tk_over, tk_out, pchr_copyright, tk_asn, tk_verify, '|';
	defb tk_merge, ']', tk_flash, tk_acs, tk_ink, '[', tk_beep;

org $0260;
kt_dig_shft:
	defb ctrl_delete, ctrl_edit, ctrl_caps, ctrl_true_vid, ctrl_inv_vid;
	defb ctrl_left, ctrl_down, ctrl_up, ctrl_right, ctrl_graphics;

org $026a;
kt_sym:
	defb tk_stop, '*', '?', tk_step, tk_gr_eq, tk_to, tk_then, '^';
	defb tk_at, '-', '+', '=', '.', ',', ';', '"', tk_l_eql, '<';
	defb tk_not, '>', tk_or, '/', tk_neql, pchr_pound, tk_and, ':';

org $0284;
kt_ext_dig_shft:
	defb tk_format, tk_def_fn, tk_fn, tk_line, tk_open, tk_close;
	defb tk_move, tk_erase, tk_point, tk_cat;

org $028e;
key_scan:
	ld l, 47;
	ld de, $ffff;
	ld bc, $fefe;

org $0296;
key_line:
	in a, (c);
	cpl;
	and %00011111;
	jr z, key_done;
	ld h, a;
	ld a, l;

org $029f;
key_3keys:
	inc d;
	ret nz;

org $02a1;
key_bits:
	sub 8;
	srl h;
	jr nc, key_bits;
	ld d, e;
	ld e, a;
	jr nz, key_3keys;

org $02ab;
key_done:
	dec l;
	rlc b;
	jr c, key_line;
	ld a, d;
	inc a;
	ret z;
	cp 40;
	ret z;
	cp 25;
	ret z;
	ld a, e;
	ld e, d;
	ld d, a;
	cp 24;
	ret;

org $02bf;
keyboard:
	call key_scan;
	ret nz;
	ld hl, kstate;

org $02c6;
k_st_loop:
	bit 7, (hl);
	jr nz, k_ch_set;
	inc hl;
	dec (hl);
	dec hl;
	jr nz, k_ch_set;
	ld (hl), 255;

org $02d1;
k_ch_set:
	ld a, l;
	ld hl, kstate_4;
	cp l;
	jr nz, k_st_loop;
	call k_test;
	ret nc;
	ld hl, kstate;
	cp (hl);
	jr z, k_repeat;
	ex de, hl;
	ld hl, kstate_4;
	cp (hl);
	jr z, k_repeat;
	bit 7, (hl);
	jr nz, k_new;
	ex de, hl;
	bit 7, (hl);
	ret z;

org $02f1;
k_new:
	ld e, a;
	ld (hl), a;
	inc hl;
	ld (hl), 5;
	inc hl;
	ld a, (repdel);
	ld (hl), a;
	inc hl;
	ld c, (iy + _mode);
	ld d, (iy + _flags);
	push hl;
	call k_decode;
	pop hl;
	ld (hl), a;

org $0308;
k_end:
	ld (last_k), a;
	set 5, (iy + _flags);
	ret;

org $0310;
k_repeat:
	inc hl;
	ld (hl), 5;
	inc hl;
	dec (hl);
	ret nz;
	ld a, (repper);
	ld (hl), a;
	inc hl;
	ld a, (hl);
	jr k_end;

org $031e;
k_test:
	ld b, d;
	ld d, 0;
	ld a, e;
	cp 39;
	ret nc;
	cp 24;
	jr nz, k_main;
	bit 7, b;
	ret nz;

org $032c;
k_main:
	ld hl, kt_main;
	add hl, de;
	ld a, (hl);
	scf;
	ret;

org $0333;
k_decode:
	ld a, e;
	cp ':';
	jr c, k_digit;
	dec c;
	jp m, k_klc_let;
	jr z, k_e_let;
	add a, 79;
	ret;

org $0341;
k_e_let:
	ld hl, kt_ext - 'A';
	inc b;
	jr z, k_look_up;
	ld hl, kt_ext_shft - 'A';

org $034a;
k_look_up:
	ld d, 0;
	add hl, de;
	ld a, (hl);
	ret;

org $034f;
k_klc_let:
	ld hl, kt_sym - 'A';
	bit 0, b;
	jr z, k_look_up;
	bit 3, d;
	jr z, k_tokens;
	bit 3, (iy + _flags2);
	ret nz;
	inc b;
	ret nz;
	add a, 32;
	ret;

org $0364;
k_tokens:
	add a, tk_rnd;
	ret;

org $0367;
k_digit:
	cp '0';
	ret c;
	dec c;
	jp m, k_klc_dgt;
	jr nz, k_gra_dgt;
	ld hl, kt_ext_dig_shft - '0';
	bit 5, b;
	jr z, k_look_up;
	cp '8';
	jr nc, k_8_and_9;
	sub 32;
	inc b;
	ret z;
	add a, 8;
	ret;

org $0382;
k_8_and_9:
	sub 54;
	inc b;
	ret z;
	add a, 254;
	ret;

org $0389;
k_gra_dgt:
	ld hl, kt_dig_shft - '0';
	cp '9';
	jr z, k_look_up;
	cp '0';
	jr z, k_look_up;
	and %00000111;
	add a, $80;
	inc b;
	ret z;
	xor %00001111;
	ret;

org $039d;
k_klc_dgt:
	inc b;
	ret z;
	bit 5, b;
	ld hl, kt_dig_shft - '0';
	jr nz, k_look_up;
	sub 16;
	cp '"';
	jr z, k_at_char;
	cp ' ';
	ret nz;
	ld a, '_';
	ret;

org $03b2;
k_at_char:
	ld a, '@';
	ret;

;org $03f8;
beep:
	ld de, $00c8;		// 800 Hz;
	ld hl, $0200;		// 1 quarter second;
;	jr beeper;			//;

;org $03b5;
beeper:
	di;
	ld a, l;
	srl l;
	srl l;
	cpl;
	and %00000011;
	ld c, a;
	ld b, 0;
	ld ix, be_ix_plus_3;
	add ix, bc;
	ld a, (bordcr);
	and %00111000;
	rrca;
	rrca;
	rrca;
	or %00001000;

;org $03d1;
be_ix_plus_3:
	nop;

;org $03d2;
be_ix_plus_2:
	nop;

;org $03d3;
be_ix_plus_1:
	nop;

;org $03d4;
be_ix_plus_0:
	inc b;
	inc c;

;org $03d6;
be_h_and_l_lp:
	dec c;
	jr nz, be_h_and_l_lp;
	ld c, 63;
	dec b;
	jp nz, be_h_and_l_lp;
	xor %00010000;
	out (ula), a;
	ld b, h;
	ld c, a;
	bit 4, a;
	jr nz, be_again;
	ld a, d;
	or e;
	jr z, be_end;
	ld a, c;
	ld c, l;
	dec de;
	jp (ix);

;org $03f2;
be_again:
	ld c, l;
	inc c;
	jp (ix);

;org $03f6;
be_end:
	ei;
	ret;

org $09f4;
print_out:
	call po_fetch;
	cp ' ';
	jp nc, po_able;
	cp 6;
	jr c, po_quest;
	cp 24;
	jr nc, po_quest;
	ld hl, ctlchrtab - 6;
	ld e, a;
	ld d, 0;
	add hl, de;
	ld e, (hl);
	add hl, de;
	push hl;
	jp po_fetch;

org $0a11;
ctlchrtab:
	defb po_comma - $;
	defb po_quest - $;
	defb po_back_1 - $;
	defb po_right - $;
	defb po_quest - $;
	defb po_quest - $;
	defb po_quest - $;
	defb po_enter - $;
	defb po_quest - $;
	defb po_quest - $;
	defb po_1_oper - $;
	defb po_1_oper - $;
	defb po_1_oper - $;
	defb po_1_oper - $;
	defb po_1_oper - $;
	defb po_1_oper - $;
	defb po_2_oper - $;
	defb po_2_oper - $;

org $0a23;
po_back_1:
	inc c;
	ld a, 34;
	cp c;
	jr nz, po_back_3;
	bit 1, (iy + _flags);
	jr nz, po_back_2;
	inc b;
	ld c, 2;
	ld a, 24;
	cp b;
	jr nz, po_back_3;
	dec b;

org $0a38;
po_back_2:
	ld c, 33;

org $0a3a;
po_back_3:
	jp cl_set;

org $0a3d;
po_right:
	ld a, (p_flag);
	push af;
	ld (iy + _p_flag), $01;
	ld a, ' ';
	call po_char;
	pop af;
	ld (p_flag), a;
	ret;

org $0a4f;
po_enter:
	bit 1, (iy + _flags);
	jp nz, copy_buff;
	ld c, 33;
	call po_scr;
	dec b;
	jp cl_set;

org $0a5f;
po_comma:
	call po_fetch;
	ld a, c;
	dec a;
	dec a;
	and %00010000;
	jr po_fill;

org $0a69;
po_quest:
	ld a, '?';
	jr po_able;

org $0a6d;
po_vdu_2:
	ld de, po_cont;
	ld (vdu_data_h), a;
	jr po_change;

org $0a75;
po_2_oper:
	ld de, po_vdu_2;
	jr po_vdu_1;

org $0a7a;
po_1_oper:
	ld de, po_cont;

org $0a7d;
po_vdu_1:
	ld (vdu_data), a;

org $0a80;
po_change:
	ld hl, (curchl);
	ld (hl), e;
	inc hl;
	ld (hl), d;
	ret;

org $0a87;
po_cont:
	ld de, print_out;
	call po_change;
	ld hl, (vdu_data);
	ld d, a;
	ld a, l;
	cp 22;
	jp c, co_temp_5;
	jr nz, po_tab;
	ld b, h;
	ld c, d;
	ld a, 31;
	sub c;
	jr c, po_at_err;
	add a, 2;
	ld c, a;
	bit 1, (iy + _flags);
	jr nz, po_at_set;
	ld a, 22;
	sub b;

org $0aac;
po_at_err:
	jp c, report_bb;
	inc a;
	ld b, a;
	inc b;
	bit 0, (iy + _vdu_flag);
	jp nz, po_scr;
	cp (iy + _df_sz);
	jp c, report_5;

org $0abf;
po_at_set:
	jp cl_set;

org $0ac2;
po_tab:
	ld a, h;

org $0ac3;
po_fill:
	call po_fetch;
	add a, c;
	dec a;
	and %00011111;
	ret z;
	ld d, a;
	set 0, (iy + _flags);

org $0ad0;
po_space:
	ld a, ' ';
	call po_save;
	dec d;
	jr nz, po_space;
	ret;

org $0ad9;
po_able:
	call po_any;

org $0adc;
po_store:
	bit 1, (iy + _flags);
	jr nz, po_st_pr;
	bit 0, (iy + _vdu_flag);
	jr nz, po_st_e;
	ld (s_posn), bc;
	ld (df_cc), hl;
	ret;

org $0af0;
po_st_e:
	ld (sposnl), bc;
	ld (echo_e), bc;
	ld (df_ccl), hl;
	ret;

org $0afc;
po_st_pr:
	ld (iy + _p_posn), c;
	ld (pr_cc), hl;
	ret;

org $0b03;
po_fetch:
	bit 1, (iy + _flags);
	jr nz, po_f_pr;
	ld bc, (s_posn);
	ld hl, (df_cc);
	bit 0, (iy + _vdu_flag);
	ret z;
	ld bc, (sposnl);
	ld hl, (df_ccl);
	ret;

org $0b1d;
po_f_pr:
	ld c, (iy + _p_posn);
	ld hl, (pr_cc);
	ret;

org $0b24;
po_any:
	cp $80;
	jr c, po_char;
	cp 144;
	jr nc, po_t_and_udg;
	ld b, a;
	call po_gr_1;
	call po_fetch;
	ld de, membot;
	jr pr_all;

org $0b38;
po_gr_1:
	ld hl, membot;
	call po_gr_2;

org $0b3e;
po_gr_2:
	rr b;
	sbc a, a;
	and %00001111;
	ld c, a;
	rr b;
	sbc a, a;
	and %11110000;
	or c;
	ld c, 4;

org $0b4c;
po_gr_3:
	ld (hl), a;
	inc hl;
	dec c;
	jr nz, po_gr_3;
	ret;

org $0b52;
po_t_and_udg:
	sub tk_rnd;
	jr nc, po_t;
	add a, 21;
	push bc;
	ld bc, (udg);
	jr po_char_2;

org $0b5f;
po_t:
	call po_tokens;
	jp po_fetch;

org $0b65;
po_char:
	push bc;
	ld bc, (chars);

org $0b6a;
po_char_2:
	ex de, hl;
	ld hl, flags;
	res 0, (hl);
	cp ' ';
	jr nz, po_char_3;
	set 0, (hl);

org $0b76;
po_char_3:
	ld h, 0;
	ld l, a;
	add hl, hl;
	add hl, hl;
	add hl, hl;
	add hl, bc;
	pop bc;
	ex de, hl;

org $0b7f;
pr_all:
	ld a, c;
	dec a;
	ld a, 33;
	jr nz, pr_all_1;
	dec b;
	ld c, a;
	bit 1, (iy + _flags);
	jr z, pr_all_1;
	push de;
	call copy_buff;
	pop de;
	ld a, c;

org $0b93;
pr_all_1:
	cp c;
	push de;
	call z, po_scr;
	pop de;
	push bc;
	push hl;
	ld a, (p_flag);
	ld b, 255;
	rra;
	jr c, pr_all_2;
	inc b;

org $0ba4;
pr_all_2:
	rra;
	rra;
	sbc a, a;
	ld c, a;
	ld a, 8;
	and a;
	bit 1, (iy + _flags);
	jr z, pr_all_3;
	set 1, (iy + _flags2);
	scf;

org $0bb6;
pr_all_3:
	ex de, hl;

org $0bb7;
pr_all_4:
	ex af, af';
	ld a, (de);
	and b;
	xor (hl);
	xor c;
	ld (de), a;
	ex af, af';
	jr c, pr_all_6;
	inc d;

org $0bc1;
pr_all_5:
	inc hl;
	dec a;
	jr nz, pr_all_4;
	ex de, hl;
	dec h;
	bit 1, (iy + _flags);
	call z, po_attr;
	pop hl;
	pop bc;
	dec c;
	inc hl;
	ret;

org $0bd3;
pr_all_6:
	ex af, af';
	ld a, 32;
	add a, e;
	ld e, a;
	ex af, af';
	jr pr_all_5;

org $0bdb;
po_attr:
	ld a, h;
	rrca;
	rrca;
	rrca;
	and %00000011;
	or %01011000;
	ld h, a;
	ld de, (attr_t);
	ld a, (hl);
	xor e;
	and d;
	xor e;
	bit 6, (iy + _p_flag);
	jr z, $0bfa;
	and %11000111;
	bit 2, a;
	jr nz, po_attr_1;
	xor %00111000;

org $0bfa;
po_attr_1:
	bit 4, (iy + _p_flag);
	jr z, po_attr_2;
	and %11111000;
	bit 5, a;
	jr nz, po_attr_2;
	xor %00000111;

org $0c08;
po_attr_2:
	ld (hl), a;
	ret;

org $0c0a;
po_msg:
	push hl;
	ld h, 0;
	ex (sp), hl;
	jr po_table;

org $0c10;
po_tokens:
	ld de, token_table;
	push af;

org $0c14;
po_table:
	call po_search;
	jr c, po_each;
	ld a, ' ';
	bit 0, (iy + _flags);
	call z, po_save;

org $0c22;
po_each:
	ld a, (de);
	and %01111111;
	call po_save;
	ld a, (de);
	inc de;
	add a, a;
	jr nc, po_each;
	pop de;
	cp 72;
	jr z, po_tr_sp;
	cp 130;
	ret c;

org $0c35;
po_tr_sp:
	ld a, d;
	cp 3;
	ret c;
	ld a, ' ';

org $0c3b;
po_save:
	push de;
	exx;
	rst print_a;
	exx;
	pop de;
	ret;

org $0c41;
po_search:
	push af;
	ex de, hl;
	inc a;

org $0c44;
po_step:
	bit 7, (hl);
	inc hl;
	jr z, po_step;
	dec a;
	jr nz, po_step;
	ex de, hl;
	pop af;
	cp ' ';
	ret c;
	ld a, (de);
	sub 'A';
	ret;

org $0c55;
po_scr:
	bit 1, (iy + _flags);
	ret nz;
	ld de, cl_set;
	push de;
	ld a, b;
	bit 0, (iy + _vdu_flag);
	jp nz, po_scr_4;
	cp (iy + _df_sz);
	jr c, report_5;
	ret nz;
	bit 4, (iy + _vdu_flag);
	jr z, po_scr_2;
	ld e, (iy + _breg);
	dec e;
	jr z, po_scr_3;
	ld a, 0;
	call chan_open;
	ld sp, (list_sp);
	res 4, (iy + _vdu_flag);
	ret;

org $0c86;
report_5:
	rst error;
	defb out_of_screen;

org $0c88;
po_scr_2:
	dec (iy + _scr_ct);
	jr nz, po_scr_3;
	ld a, 24;
	sub b;
	ld (scr_ct), a;
	ld hl, (attr_t);
	push hl;
	ld a, (p_flag);
	push af;
	ld a, 253;
	call chan_open;
	xor a;
	ld de, scrl_mssg;
	call po_msg;
	set 5, (iy + _vdu_flag);
	ld hl, flags;
	set 3, (hl);
	res 5, (hl);
	exx;
	call wait_key;
	exx;
	cp ' ';
	jr z, report_d;
	cp tk_stop;
	jr z, report_d;
	or %00100000;
	cp 'n';
	jr z, report_d;
	ld a, 254;
	call chan_open;
	pop af;
	ld (p_flag), a;
	pop hl;
	ld (attr_t), hl;

org $0cd2;
po_scr_3:
	call cl_sc_all;
	ld b, (iy + _df_sz);
	inc b;
	ld c, 33;
	push bc;
	call cl_addr;
	ld a, h;
	rrca;
	rrca;
	rrca;
	and %00000011;
	or %01011000;
	ld h, a;
	ld de, attrmap + $02e0;
	ld a, (de);
	ld c, (hl);
	ld b, 32;
	ex de, hl;

org $0cf0;
po_scr_3a:
	ld (de), a;
	ld (hl), c;
	inc de;
	inc hl;
	djnz po_scr_3a;
	pop bc;
	ret;

org $0cf8;
scrl_mssg:
	defb $80, "scroll", '?' + $80;

org $0d00;
report_d:
	rst error;
	defb break_cont_repeats;

org $0d02;
po_scr_4:
	cp 2;
	jr c, report_5;
	add a, (iy + _df_sz);
	sub 25;
	ret nc;
	neg;
	push bc;
	ld b, a;
	ld hl, (attr_t);
	push hl;
	ld hl, (p_flag);
	push hl;
	call temps;
	ld a, b;

org $0d1c;
po_scr_4a:
	push af;
	ld hl, df_sz;
	ld b, (hl);
	ld a, b;
	inc a;
	ld (hl), a;
	ld hl, s_posn_h;
	cp (hl);
	jr c, po_scr_4b;
	inc (hl);
	ld b, 24;

org $0d2d;
po_scr_4b:
	call cl_scroll;
	pop af;
	dec a;
	jr nz, po_scr_4a;
	pop hl;
	ld (iy + _p_flag), l;
	pop hl;
	ld (attr_t), hl;
	ld bc, (s_posn);
	res 0, (iy + _vdu_flag);
	call cl_set;
	set 0, (iy + _vdu_flag);
	pop bc;
	ret;

org $0d4d;
temps:
	xor a;
	ld hl, (attr_p);
	bit 0, (iy + _vdu_flag);
	jr z, temps_1;
	ld h, a;
	ld l, (iy + _bordcr);

org $0d5b;
temps_1:
	ld (attr_t), hl;
	ld hl, p_flag;
	jr nz, temps_2;
	ld a, (hl);
	rrca;

org $0d65;
temps_2:
	xor (hl);
	and %01010101;
	xor (hl);
	ld (hl), a;
	ret;

org $0d6b;
cls:
	call cl_all;

org $0d6e;
cls_lower:
	ld hl, vdu_flag;
	res 5, (hl);
	set 0, (hl);
	call temps;
	ld b, (iy + _df_sz);
	call cl_line;
	ld hl, attrmap + $02c0;
	ld a, (attr_p);
	dec b;
	jr cls_3;

org $0d87;
cls_1:
	ld c, 32;

org $0d89;
cls_2:
	dec hl;
	ld (hl), a;
	dec c;
	jr nz, cls_2;

org $0d8e;
cls_3:
	djnz cls_1;
	ld (iy + _df_sz), $02;

org $0d94;
cl_chan:
	ld a, 253;
	call chan_open;
	ld hl, (curchl);
	ld de, print_out;
	and a;

org $0da0;
cl_chan_a:
	ld (hl), e;
	inc hl;
	ld (hl), d;
	inc hl;
	ld de, key_input;
	ccf;
	jr c, cl_chan_a;
	ld bc, $1721;
	jr cl_set;

org $0daf;
cl_all:
	ld hl, $0000;
	ld (coords), hl;
	res 0, (iy + _flags2);
	call cl_chan;
	ld a, 254;
	call chan_open;
	call temps;
	ld b, 24;
	call cl_line;
	ld hl, (curchl);
	ld de, print_out;
	ld (hl), e;
	inc hl;
	ld (hl), d;
	ld (iy + _scr_ct), 1;
	ld bc, $1821;

org $0dd9;
cl_set:
	ld hl, prt_buff;
	bit 1, (iy + _flags);
	jr nz, cl_set_2;
	ld a, b;
	bit 0, (iy + _vdu_flag);
	jr z, cl_set_1;
	add a, (iy + _df_sz);
	sub 24;

org $0dee;
cl_set_1:
	push bc;
	ld b, a;
	call cl_addr;
	pop bc;

org $0df4;
cl_set_2:
	ld a, 33;
	sub c;
	ld e, a;
	ld d, 0;
	add hl, de;
	jp po_store;

org $0dfe;
cl_sc_all:
	ld b, 23;

org $0e00;
cl_scroll:
	call cl_addr;
	ld c, 8;

org $0e05;
cl_scr_1:
	push bc;
	push hl;
	ld a, b;
	and %00000111;
	ld a, b;
	jr nz, cl_scr_3;

org $0e0d;
cl_scr_2:
	ex de, hl;
	ld hl, $f8e0;
	add hl, de;
	ex de, hl;
	ld bc, $0020;
	dec a;
	ldir;

org $0e19;
cl_scr_3:
	ex de, hl;
	ld hl, $ffe0;
	add hl, de;
	ex de, hl;
	ld b, a;
	and %00000111;
	rrca;
	rrca;
	rrca;
	ld c, a;
	ld a, b;
	ld b, 0;
	ldir;
	ld b, 7;
	add hl, bc;
	and %11111000;
	jr nz, cl_scr_2;
	pop hl;
	inc h;
	pop bc;
	dec c;
	jr nz, cl_scr_1;
	call cl_attr;
	ld hl, $ffe0;
	add hl, de;
	ex de, hl;
	ldir;
	ld b, 1;

org $0e44;
cl_line:
	push bc;
	call cl_addr;
	ld c, 8;

org $0e4a;
cl_line_1:
	push bc;
	push hl;
	ld a, b;

org $0e4d;
cl_line_2:
	and %00000111;
	rrca;
	rrca;
	rrca;
	ld c, a;
	ld a, b;
	ld b, 0;
	dec c;
	ld d, h;
	ld e, l;
	ld (hl), 0;
	inc de;
	ldir;
	ld de, $0701;
	add hl, de;
	dec a;
	and %11111000;
	ld b, a;
	jr nz, cl_line_2;
	pop hl;
	inc h;
	pop bc;
	dec c;
	jr nz, cl_line_1;
	call cl_attr;
	ld h, d;
	ld l, e;
	inc de;
	ld a, (attr_p);
	bit 0, (iy + _vdu_flag);
	jr z, cl_line_3;
	ld a, (bordcr);

org $0e80;
cl_line_3:
	ld (hl), a;
	dec bc;
	ldir;
	pop bc;
	ld c, 33;
	ret;

org $0e88;
cl_attr:
	ld a, h;
	rrca;
	rrca;
	rrca;
	dec a;
	or %01010000;
	ld h, a;
	ex de, hl;
	ld h, c;
	ld l, b;
	add hl, hl;
	add hl, hl;
	add hl, hl;
	add hl, hl;
	add hl, hl;
	ld b, h;
	ld c, l;
	ret;

org $0e9b;
cl_addr:
	ld a, 24;
	sub b;
	ld d, a;
	rrca;
	rrca;
	rrca;
	and %11100000;
	ld l, a;
	ld a, d;
	and %00011000;
	or %01000000;
	ld h, a;
	ret;

org $0eac;
copy:
	di;
	ld b, 176;
	ld hl, pixelmap;

org $0eb2;
copy_1:
	push hl;
	push bc;
	call copy_line;
	pop bc;
	pop hl;
	inc h;
	ld a, h;
	and %00000111;
	jr nz, copy_2;
	ld a, l;
	add a, 32;
	ld l, a;
	ccf;
	sbc a, a;
	and %11111000;
	add a, h;
	ld h, a;

org $0ec9;
copy_2:
	djnz copy_1;
	jr copy_end;

org $0ecd;
copy_buff:
	di;
	ld hl, prt_buff;
	ld b, 8;

org $0ed3;
copy_3:
	push bc;
	call copy_line;
	pop bc;
	djnz copy_3;

org $0eda;
copy_end:
	ld a, 4;
	out (printer), a;
	ei;

org $0edf;
clear_prb:
	ld hl, prt_buff;
	ld (iy + _pr_cc), l;
	xor a;
	ld b, a;

org $0ee7;
prb_bytes:
	ld (hl), a;
	inc hl;
	djnz prb_bytes;
	res 1, (iy + _flags2);
	ld c, 33;
	jp cl_set;

org $0ef4;
copy_line:
	ld a, b;
	cp 3;
	sbc a, a;
	and %00000010;
	out (printer), a;
	ld d, a;

org $0efd;
copy_l_1:
	call break_key;
	jr c, copy_l_2;
	ld a, 4;
	out (printer), a;
	ei;
	call clear_prb;

org $0f0a;
report_dc:
	rst error;
	defb break_cont_repeats;

org $0f0c;
copy_l_2:
	in a, (printer);
	add a, a;
	ret m;
	jr nc, copy_l_1;
	ld c, 32;

org $0f14;
copy_l_3:
	ld e, (hl);
	inc hl;
	ld b, 8;

org $0f18;
copy_l_4:
	rl d;
	rl e;
	rr d;

org $0f1e;
copy_l_5:
	in a, (printer);
	rra;
	jr nc, copy_l_5;
	ld a, d;
	out (printer), a;
	djnz copy_l_4;
	dec c;
	jr nz, copy_l_3;
	ret;

org $0f2c;
editor:
	ld hl, (err_sp);
	push hl;

org $0f30;
ed_again:
	ld hl, ed_error;
	push hl;
	ld (err_sp), sp;

org $0f38;
ed_loop:
	call wait_key;
	push af;
	ld d, 0;
	ld e, (iy - _pip);
	ld hl, $00c8;
	call beeper;
	pop af;
	ld hl, ed_loop;
	push hl;
	cp 24;
	jr nc, add_char;
	cp 7;
	jr c, add_char;
	cp 16;
	jr c, ed_keys;
	ld bc, $0002;
	ld d, a;
	cp 22;
	jr c, ed_contr;
	inc bc;
	bit 7, (iy + _flagx);
	jp z, ed_ignore;
	call wait_key;
	ld e, a;

org $0f6c;
ed_contr:
	call wait_key;
	push de;
	ld hl, (k_cur);
	res 0, (iy + _mode);
	call make_room;
	pop bc;
	inc hl;
	ld (hl), b;
	inc hl;
	ld (hl), c;
	jr add_ch_1;

org $0f81;
add_char:
	res 0, (iy + _mode);
	ld hl, (k_cur);
	call one_space;

org $0f8b;
add_ch_1:
	ld (de), a;
	inc de;
	ld (k_cur), de;
	ret;

org $0f92;
ed_keys:
	ld e, a;
	ld d, 0;
	ld hl, ed_keys_t - 7;
	add hl, de;
	ld e, (hl);
	add hl, de;
	push hl;
	ld hl, (k_cur);
	ret;

org $0fa0;
ed_keys_t:
	defb ed_edit - $;
	defb ed_left - $;
	defb ed_right - $;
	defb ed_down - $;
	defb ed_up - $;
	defb ed_delete - $;
	defb ed_enter - $;
	defb ed_symbol - $;
	defb ed_graph - $;

org $0fa9;
ed_edit:
	ld hl, (e_ppc);
	bit 5, (iy + _flagx);
	jp nz, clear_sp;
	call line_addr;
	call line_no;
	ld a, d;
	or e;
	jp z, clear_sp;
	push hl;
	inc hl;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	ld hl, $000a;
	add hl, bc;
	ld b, h;
	ld c, l;
	call test_room;
	call clear_sp;
	ld hl, (curchl);
	ex (sp), hl;
	push hl;
	ld a, 255;
	call chan_open;
	pop hl;
	dec hl;
	dec (iy + _e_ppc);
	call out_line;
	inc (iy + _e_ppc);
	ld hl, (e_line);
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	ld (k_cur), hl;
	pop hl;
	call chan_flag;
	ret;

org $0ff3;
ed_down:
	bit 5, (iy + _flagx);
	jr nz, ed_stop;
	ld hl, e_ppc;
	call ln_fetch;
	jr ed_list;

org $1001;
ed_stop:
	ld (iy + _err_nr), 16;
	jr ed_enter;

org $1007;
ed_left:
	call ed_edge;
	jr ed_cur;

org $100c;
ed_right:
	ld a, (hl);
	cp 13;
	ret z;
	inc hl;

org $1011;
ed_cur:
	ld (k_cur), hl;
	ret;

org $1015;
ed_delete:
	call ed_edge;
	ld bc, $0001;
	jp reclaim_2;

org $101e;
ed_ignore:
	call wait_key;
	call wait_key;

org $1024;
ed_enter:
	pop hl;
	pop hl;

org $1026;
ed_end:
	pop hl;
	ld (err_sp), hl;
	bit 7, (iy + _err_nr);
	ret nz;
	ld sp, hl;
	ret;

org $1031;
ed_edge:
	scf;
	call set_de;
	sbc hl, de;
	add hl, de;
	inc hl;
	pop bc;
	ret c;
	push bc;
	ld b, h;
	ld c, l;

org $103e;
ed_edge_1:
	ld h, d;
	ld l, e;
	inc hl;
	ld a, (de);
	and %11110000;
	cp ctrl_ink;
	jr nz, ed_edge_2;
	inc hl;
	ld a, (de);
	sub ctrl_tab;
	adc a, 0;
	jr nz, ed_edge_2;
	inc hl;

org $1051;
ed_edge_2:
	and a;
	sbc hl, bc;
	add hl, bc;
	ex de, hl;
	jr c, ed_edge_1;
	ret;

org $1059;
ed_up:
	bit 5, (iy + _flagx);
	ret nz;
	ld hl, (e_ppc);
	call line_addr;
	ex de, hl;
	call line_no;
	ld hl, e_ppc_h;
	call ln_store;

org $106e;
ed_list:
	call auto_list;
	ld a, 0;
	jp chan_open;

org $1076;
ed_symbol:
	bit 7, (iy + _flagx);
	jr z, ed_enter;

org $107c;
ed_graph:
	jp add_char;

org $107f;
ed_error:
	bit 4, (iy + _flags2);
	jr z, ed_end;
	ld (iy + _err_nr), 255;
	ld d, 0;
	ld e, (iy - _rasp);
	ld hl, $1a90;
	call beeper;
	jp ed_again;

org $1097;
clear_sp:
	push hl;
	call set_hl;
	dec hl;
	call reclaim_1;
	ld (k_cur), hl;
	ld (iy + $07), 0;
	pop hl;
	ret;

org $10a8;
key_input:
	bit 3, (iy + _vdu_flag);
	call nz, ed_copy;
	and a;
	bit 5, (iy + _flags);
	ret z;
	ld a, (last_k);
	res 5, (iy + _flags);
	push af;
	bit 5, (iy + _vdu_flag);
	call nz, cls_lower;
	pop af;
	cp ' ';
	jr nc, key_done2;
	cp ctrl_ink;
	jr nc, key_contr;
	cp 6;
	jr nc, key_m_cl;
	ld b, a;
	and %00000001;
	ld c, a;
	ld a, b;
	rra;
	add a, 18;
	jr key_data;

org $10db;
key_m_cl:
	jr nz, key_mode;
	ld hl, flags2;
	ld a, %00001000;
	xor (hl);
	ld (hl), a;
	jr key_flag;

org $10e6;
key_mode:
	cp ctrl_symbol;
	ret c;
	sub 13;
	ld hl, mode;
	cp (hl);
	ld (hl), a;
	jr nz, key_flag;
	ld (hl), 0;

org $10f4;
key_flag:
	set 3, (iy + _vdu_flag);
	cp a;
	ret;

org $10fa;
key_contr:
	ld b, a;
	and %00000111;
	ld c, a;
	ld a, ctrl_ink;
	bit 3, b;
	jr nz, key_data;
	inc a;

org $1105;
key_data:
	ld (iy - _k_data), c;
	ld de, key_next;
	jr key_chan;

org $110d;
key_next:
	ld a, (k_data);
	ld de, key_input;

org $1113;
key_chan:
	ld hl, (chans);
	inc hl;
	inc hl;
	ld (hl), e;
	inc hl;
	ld (hl), d;

org $111b;
key_done2:
	scf;
	ret;

org $111d;
ed_copy:
	call temps;
	res 3, (iy + _vdu_flag);
	res 5, (iy + _vdu_flag);
	ld hl, (sposnl);
	push hl;
	ld hl, (err_sp);
	push hl;
	ld hl, ed_full;
	push hl;
	ld (err_sp), sp;
	ld hl, (echo_e);
	push hl;
	scf;
	call set_de;
	ex de, hl;
	call out_line2;
	ex de, hl;
	call out_curs;
	ld hl, (sposnl);
	ex (sp), hl;
	ex de, hl;
	call temps;

org $1150;
ed_blank:
	ld a, (sposnl_h);
	sub d;
	jr c, ed_c_done;
	jr nz, ed_spaces;
	ld a, e;
	sub (iy + $50) ;sposnl;
	jr nc, ed_c_done;

org $115e;
ed_spaces:
	ld a, ' ';
	push de;
	call print_out;
	pop de;
	jr ed_blank;

org $1167;
ed_full:
	ld d, 0;
	ld e, (iy - _rasp);
	ld hl, $1a90;
	call beeper;
	ld (iy + _err_nr), 255;
	ld de, (sposnl);
	jr ed_c_end;

org $117c;
ed_c_done:
	pop de;
	pop hl;

org $117e;
ed_c_end:
	pop hl;
	ld (err_sp), hl;
	pop bc;
	push de;
	call cl_set;
	pop hl;
	ld (echo_e), hl;
	ld (iy + _x_ptr_h), 0;
	ret;

org $1190;
set_hl:
	ld hl, (worksp);
	dec hl;
	and a;

org $1195;
set_de:
	ld de, (e_line);
	bit 5, (iy + _flagx);
	ret z;
	ld de, (worksp);
	ret c;
	ld hl, (stkbot);
	ret;

org $11a7;
remove_fp:
	ld a, (hl);
	cp $0e;
	ld bc, $0006;
	call z, reclaim_2;
	ld a, (hl);
	inc hl;
	cp ctrl_enter;
	jr nz, remove_fp;
	ret;

org $11b7;
new:
	di;
	ld a, 255;
	ld de, (ramtop);
	exx;
	ld bc, (p_ramt);
	ld de, (rasp);
	ld hl, (udg);
	exx;

org $11cb;
start_new:
	ld b, a;
	ld a, white;
	out (ula), a;
	ld a, 63;
	ld i, a;
	nop;
	nop;
	nop;
	nop;
	nop;
	nop;

org $11da;
ram_check:
	ld h, d;
	ld l, e;

org $11dc;
ram_fill:
	ld (hl), red;
	dec hl;
	cp h;
	jr nz, ram_fill;

org $11e2;
ram_read:
	and a;
	sbc hl, de;
	add hl, de;
	inc hl;
	jr nc, ram_done;
	dec (hl);
	jr z, ram_done;
	dec (hl);
	jr z, ram_read;

org $11ef;
ram_done:
	dec hl;
	exx;
	ld (p_ramt), bc;
	ld (rasp), de;
	ld (udg), hl;
	exx;
	inc b;
	jr z, ram_set;
	ld (p_ramt), hl;
	ld de, font + $02af;
	ld bc, $00a8;
	ex de, hl;
	lddr;
	ex de, hl;
	inc hl;
	ld (udg), hl;
	dec hl;
	ld bc, $0040;
	ld (rasp), bc;

org $1219;
ram_set:
	ld (ramtop), hl;
	ld hl, font;
	ld (chars), hl;
	ld hl, (ramtop);
	ld (hl), $3e;
	dec hl;
	ld sp, hl;
	dec hl;
	dec hl;
	ld (err_sp), hl;
	im 1;
	ld iy, err_nr;
	ei;
	ld hl, channels;
	ld (chans), hl;
	ld de, init_chan;
	ld bc, $0015;
	ex de, hl;
	ldir;
	ex de, hl;
	dec hl;
	ld (datadd), hl;
	inc hl;
	ld (prog), hl;
	ld (vars), hl;
	ld (hl), $80;
	inc hl;
	ld (e_line), hl;
	ld (hl), ctrl_enter;
	inc hl;
	ld (hl), $80;
	inc hl;
	ld (worksp), hl;
	ld (stkbot), hl;
	ld (stkend), hl;
	ld a, 56;
	ld (attr_p), a;
	ld (attr_t), a;
	ld (bordcr), a;
	ld hl, $0523;
	ld (repdel), hl;
	dec (iy - _kstate);
	dec (iy - _kstate_4);
	ld hl, init_strm;
	ld de, strms;
	ld bc, $000e;
	ldir;
	set 1, (iy + _flags);
	call clear_prb;
	ld (iy + _df_sz), 2;
	call cls;
	xor a;
	ld de, copyright - 1;
	call po_msg;
	set 5, (iy + _vdu_flag);
	jr main_1;

org $12a2;
main_exec:
	ld (iy + _df_sz), 2;
	call auto_list;

org $12a9;
main_1:
	call set_min;

org $12ac;
main_2:
	ld a, 0;
	call chan_open;
	call editor;
	call line_scan;
	bit 7, (iy + _err_nr);
	jr nz, main_3;
	bit 4, (iy + _flags2);
	jr z, main_4;
	ld hl, (e_line);
	call remove_fp;
	ld (iy + _err_nr), 255;
	jr main_2;

org $12cf;
main_3:
	ld hl, (e_line);
	ld (ch_add), hl;
	call e_line_no;
	ld a, b;
	or c;
	jp nz, main_add;
	rst get_char;
	cp ctrl_enter;
	jr z, main_exec;
	bit 0, (iy + _flags2);
	call nz, cl_all;
	call cls_lower;
	ld a, 25;
	sub (iy + _s_posn_h);
	ld (scr_ct), a;
	set 7, (iy + _flags);
	ld (iy + _err_nr), 255;
	ld (iy + _nsppc), 1;
	call line_run;

org $1303;
main_4:
	halt;
	res 5, (iy + _flags);
	bit 1, (iy + _flags2);
	call nz, copy_buff;
	ld a, (err_nr);
	inc a;

org $1313;
main_g:
	push af;
	ld hl, $0000;
	ld (iy + _flagx), h;
	ld (iy + _x_ptr_h), h;
	ld (defadd), hl;
	ld hl, $0001;
	ld (strms_00), hl;
	call set_min;
	res 5, (iy + _flagx);
	call cls_lower;
	set 5, (iy + _vdu_flag);
	pop af;
	ld b, a;
	cp 10;
	jr c, main_5;
	add a, 7;

org $133c;
main_5:
	call out_code;
	ld a, ' ';
	rst print_a;
	ld a, b;
	ld de, rpt_mesgs;
	call po_msg;
	xor a;
	ld de, comma_sp - 1;
	call po_msg;
	ld bc, (ppc);
	call out_num_1;
	ld a, ':';
	rst print_a;
	ld c, (iy + _subppc);
	ld b, 0;
	call out_num_1;
	call clear_sp;
	ld a, (err_nr);
	inc a;
	jr z, main_9;
	cp 9;
	jr z, main_6;
	cp 21;
	jr nz, main_7;

org $1373;
main_6:
	inc (iy + _subppc);

org $1376;
main_7:
	ld bc, $0003;
	ld de, osppc;
	ld hl, nsppc;
	bit 7, (hl);
	jr z, main_8;
	add hl, bc;

org $1384;
main_8:
	lddr;

org $1386;
main_9:
	ld (iy + _nsppc), 255;
	res 3, (iy + _flags);
	jp main_2;

org $1391;
rpt_mesgs:
	defb $80;
	defb 'O', 'K' + $80;
	defb "NEXT without FO", 'R' + $80;
	defb "Variable not foun", 'd' + $80;
	defb "Subscript wron", 'g' + $80;
	defb "Out of memor", 'y' + $80;
	defb "Out of scree", 'n' + $80;
	defb "Number too bi", 'g' + $80;
	defb "RETURN without GOSU", 'B' + $80;
	defb "End of fil", 'e' + $80;
	defb "STOP statemen", 't' + $80;
	defb "Invalid argumen", 't' + $80;
	defb "Integer out of rang", 'e' + $80;
	defb "Nonsense in BASI", 'C' + $80;
	defb "BREAK - CONT repeat", 's' + $80;
	defb "Out of DAT", 'A' + $80;
	defb "Invalid file nam", 'e' + $80;
	defb "No room for lin", 'e' + $80;
	defb "STOP in INPU", 'T' + $80;
	defb "FOR without NEX", 'T' + $80;
	defb "Invalid I/O devic", 'e' + $80;
	defb "Invalid colou", 'r' + $80;
	defb "BREAK into progra", 'm' + $80;
	defb "RAMTOP no goo", 'd' + $80;
	defb "Statement los", 't' + $80;
	defb "Invalid strea", 'm' + $80;
	defb "FN without DE", 'F' + $80;
	defb "Parameter erro", 'r' + $80;
	defb "Tape loading erro", 'r' + $80;

org $1537;
comma_sp:
	defb ',', ' ' + $80;

org $1539;
copyright:
	defb pchr_copyright, " 1982 Sinclair Research Lt", 'd' + $80;

org $1555;
report_g:
	ld a, 16;
	ld bc, $0000;
	jp main_g;

org $155d;
main_add:
	ld (e_ppc), bc;
	ld hl, (ch_add);
	ex de, hl;
	ld hl, report_g;
	push hl;
	ld hl, (worksp);
	scf;
	sbc hl, de;
	push hl;
	ld h, b;
	ld l, c;
	call line_addr;
	jr nz, main_add1;
	call next_one;
	call reclaim_2;

org $157d;
main_add1:
	pop bc;
	ld a, c;
	dec a;
	or b;
	jr z, main_add2;
	push bc;
	inc bc;
	inc bc;
	inc bc;
	inc bc;
	dec hl;
	ld de, (prog);
	push de;
	call make_room;
	pop hl;
	ld (prog), hl;
	pop bc;
	push bc;
	inc de;
	ld hl, (worksp);
	dec hl;
	dec hl;
	lddr;
	ld hl, (e_ppc);
	ex de, hl;
	pop bc;
	ld (hl), b;
	dec hl;
	ld (hl), c;
	dec hl;
	ld (hl), e;
	dec hl;
	ld (hl), d;

org $15ab;
main_add2:
	pop af;
	jp main_exec;

org $15af;
init_chan:
	defw print_out, key_input;
	defb 'K';
	defw print_out, report_j;
	defb 'S';
	defw add_char, report_j;
	defb 'R';
	defw print_out, report_j;
	defb 'P', $80;

org $15c4;
report_j:
	rst error;
	defb invalid_io_device;

org $15c6;
init_strm:
	defb $01, $00;
	defb $06, $00;
	defb $0b, $00;
	defb $01, $00;
	defb $01, $00;
	defb $06, $00;
	defb $10, $00;

org $15d4;
wait_key:
	bit 5, (iy + _vdu_flag);
	jr nz, wait_key1;
	set 3, (iy + _vdu_flag);

org $15de;
wait_key1:
	call input_ad;
	ret c;
	jr z, wait_key1;

org $15e4;
report_8:
	rst error;
	defb end_of_file;

org $15e6;
input_ad:
	exx;
	push hl;
	ld hl, (curchl);
	inc hl;
	inc hl;
	jr call_sub;

org $15ef;
out_code:
	ld e, '0';
	add a, e;

org $15f2;
print_a_2:
	exx;
	push hl;
	ld hl, (curchl);

org $15f7;
call_sub:
	ld e, (hl);
	inc hl;
	ld d, (hl);
	ex de, hl;
	call call_jump;
	pop hl;
	exx;
	ret;

org $1601;
chan_open:
	add a, a;
	add a, 22;
	ld l, a;
	ld h, 92;
	ld e, (hl);
	inc hl;
	ld d, (hl);
	ld a, d;
	or e;
	jr nz, chan_op_1;

org $160e;
report_oa:
	rst error;
	defb invalid_stream;

org $1610;
chan_op_1:
	dec de;
	ld hl, (chans);
	add hl, de;

org $1615;
chan_flag:
	ld (curchl), hl;
	res 4, (iy + _flags2);
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	ld c, (hl);
	ld hl, chn_cd_lu;
	call indexer;
	ret nc;
	ld d, 0;
	ld e, (hl);
	add hl, de;

org $162c;
call_jump:
	jp (hl);

org $162d;
chn_cd_lu:
	defb 'K', chan_k - 1 - $;
	defb 'S', chan_s - 1 - $;
	defb 'P', chan_p - 1 - $;
	defb $00;

org $1634;
chan_k:
	set 0, (iy + _vdu_flag);
	res 5, (iy + _flags);
	set 4, (iy + _flags2);
	jr chan_s_1;

org $1642;
chan_s:
	res 0, (iy + _vdu_flag);

org $1646;
chan_s_1:
	res 1, (iy + _flags);
	jp temps;

org $164d;
chan_p:
	set 1, (iy + _flags);
	ret;

org $1652;
one_space:
	ld bc, $0001;

org $1655;
make_room:
	push hl;
	call test_room;
	pop hl;
	call pointers;
	ld hl, (stkend);
	ex de, hl;
	lddr;
	ret;

org $1664;
pointers:
	push af;
	push hl;
	ld hl, vars;
	ld a, 14;

org $166b;
ptr_next:
	ld e, (hl);
	inc hl;
	ld d, (hl);
	ex (sp), hl;
	and a;
	sbc hl, de;
	add hl, de;
	ex (sp), hl;
	jr nc, ptr_done;
	push de;
	ex de, hl;
	add hl, bc;
	ex de, hl;
	ld (hl), d;
	dec hl;
	ld (hl), e;
	inc hl;
	pop de;

org $167f;
ptr_done:
	inc hl;
	dec a;
	jr nz, ptr_next;
	ex de, hl;
	pop de;
	pop af;
	and a;
	sbc hl, de;
	ld b, h;
	ld c, l;
	inc bc;
	add hl, de;
	ex de, hl;
	ret;

org $168f;
line_zero:
	defw $0000;

org $1691;
line_no_a:
	ex de, hl;
	ld de, line_zero;

org $1695;
line_no:
	ld a, (hl);
	and %11000000;
	jr nz, line_no_a;
	ld d, (hl);
	inc hl;
	ld e, (hl);
	ret;

org $169e;
reserve:
	ld hl, (stkbot);
	dec hl;
	call make_room;
	inc hl;
	inc hl;
	pop bc;
	ld (worksp), bc;
	pop bc;
	ex de, hl;
	inc hl;
	ret;

org $16b0;
set_min:
	ld hl, (e_line);
	ld (hl), 13;
	ld (k_cur), hl;
	inc hl;
	ld (hl), $80;
	inc hl;
	ld (worksp), hl;

org $16bf;
set_work:
	ld hl, (worksp);
	ld (stkbot), hl;

org $16c5;
set_stk:
	ld hl, (stkbot);
	ld (stkend), hl;
	push hl;
	ld hl, membot;
	ld (mem), hl;
	pop hl;
	ret;

org $16d4;
rec_edit:
	ld de, (e_line);
	jp reclaim_1;

org $16db;
indexer_1:
	inc hl;

org $16dc;
indexer:
	ld a, (hl);
	and a;
	ret z;
	cp c;
	inc hl;
	jr nz, indexer_1;
	scf;
	ret;

org $16e5;
close:
	call str_data;
	call close_2;
	ld bc, $0000;
	ld de, $a3e2;
	ex de, hl;
	add hl, de;
	jr c, close_1;
	ld bc, init_strm + 14;
	add hl, bc;
	ld c, (hl);
	inc hl;
	ld b, (hl);

org $16fc;
close_1:
	ex de, hl;
	ld (hl), c;
	inc hl;
	ld (hl), b;
	ret;

org $1701;
close_2:
	push hl;
	ld hl, (chans);
	add hl, bc;
	inc hl;
	inc hl;
	inc hl;
	ld c, (hl);
	ex de, hl;
	ld hl, cl_str_lu;
	call indexer;
	ld c, (hl);
	ld b, 0;
	add hl, bc;
	jp (hl);

org $1716;
cl_str_lu:
	defb 'K', close_str - 1 - $;
	defb 'S', close_str - 1 - $;
	defb 'P', close_str - 1 - $;

org $171c;
close_str:
	pop hl;
	ret;

org $171e;
str_data:
	call find_int1;
	cp 16;
	jr c, str_data1;

org $1725;
report_ob:
	rst error;
	defb invalid_stream;

org $1727;
str_data1:
	add a, 3;
	rlca;
	ld hl, strms;
	ld c, a;
	ld b, 0;
	add hl, bc;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	dec hl;
	ret;

org $1736;
open:
	fwait();
	fxch();
	fce();
	call str_data;
	ld a, b;
	or c;
	jr z, open_1;
	ex de, hl;
	ld hl, (chans);
	add hl, bc;
	inc hl;
	inc hl;
	inc hl;
	ld a, (hl);
	ex de, hl;
	cp 'K';
	jr z, open_1;
	cp 'S';
	jr z, open_1;
	cp 80;
	jr nz, report_ob;

org $1756;
open_1:
	call open_2;
	ld (hl), e;
	inc hl;
	ld (hl), d;
	ret;

org $175d;
open_2:
	push hl;
	call stk_fetch;
	ld a, b;
	or c;
	jr nz, open_3;

org $1765;
report_fb:
	rst error;
	defb invalid_file_name;

org $1767;
open_3:
	push bc;
	ld a, (de);
	and %11011111;
	ld c, a;
	ld hl, op_str_lu;
	call indexer;
	jr nc, report_fb;
	ld c, (hl);
	ld b, 0;
	add hl, bc;
	pop bc;
	jp (hl);

org $177a;
op_str_lu:
	defb 'K', open_k - 1 - $;
	defb 'S', open_s - 1 - $;
	defb 'P', open_p - 1 - $;
	defb $00;

org $1781;
open_k:
	ld e, 1;
	jr open_end;

org $1785;
open_s:
	ld e, 6;
	jr open_end;

org $1789;
open_p:
	ld e, 16;

org $178b;
open_end:
	dec bc;
	ld a, b;
	or c;
	jr nz, report_fb;
	ld d, a;
	pop hl;
	ret;

org $1793;
cat_etc:
	jr report_ob;

org $1795;
auto_list:
	ld (list_sp), sp;
	ld (iy + _vdu_flag), 16;
	call cl_all;
	set 0, (iy + _vdu_flag);
	ld b, (iy + _df_sz);
	call cl_line;
	res 0, (iy + _vdu_flag);
	set 0, (iy + _flags2);
	ld hl, (e_ppc);
	ld de, (s_top);
	and a;
	sbc hl, de;
	add hl, de;
	jr c, auto_l_2;
	push de;
	call line_addr;
	ld de, $02c0;
	ex de, hl;
	sbc hl, de;
	ex (sp), hl;
	call line_addr;
	pop bc;

org $17ce;
auto_l_1:
	push bc;
	call next_one;
	pop bc;
	add hl, bc;
	jr c, auto_l_3;
	ex de, hl;
	ld d, (hl);
	inc hl;
	ld e, (hl);
	dec hl;
	ld (s_top), de;
	jr auto_l_1;

org $17e1;
auto_l_2:
	ld (s_top), hl;

org $17e4;
auto_l_3:
	ld hl, (s_top);
	call line_addr;
	jr z, auto_l_4;
	ex de, hl;

org $17ed;
auto_l_4:
	call list_all;
	res 4, (iy + _vdu_flag);
	ret;

org $17f5;
llist:
	ld a, 3;
	jr list_1;

org $17f9;
list:
	ld a, 2;

org $17fb;
list_1:
	ld (iy + _vdu_flag), 0;
	call syntax_z;
	call nz, chan_open;
	rst get_char;
	call str_alter;
	jr c, list_4;
	rst get_char;
	cp ';';
	jr z, list_2;
	cp ',';
	jr nz, list_3;

org $1814;
list_2:
	rst next_char;
	call expt_1num;
	jr list_5;

org $181a;
list_3:
	call use_zero;
	jr list_5;

org $181f;
list_4:
	call fetch_num;

org $1822;
list_5:
	call check_end;
	call find_int2;
	ld a, b;
	and %00111111;
	ld h, a;
	ld l, c;
	ld (e_ppc), hl;
	call line_addr;

org $1833;
list_all:
	ld e, 1;

org $1835;
list_all_2:
	call out_line;
	rst print_a;
	bit 4, (iy + _vdu_flag);
	jr z, list_all_2;
	ld a, (df_sz);
	sub (iy + _s_posn_h);
	jr nz, list_all_2;
	xor e;
	ret z;
	push hl;
	push de;
	ld hl, s_top;
	call ln_fetch;
	pop de;
	pop hl;
	jr list_all_2;

org $1855;
out_line:
	ld bc, (e_ppc);
	call cp_lines;
	ld d, '>';
	jr z, out_line1;
	ld de, $0000;
	rl e;

org $1865;
out_line1:
	ld (iy + $2d), e ;breg;
	ld a, (hl);
	cp 64;
	pop bc;
	ret nc;
	push bc;
	call out_num_2;
	inc hl;
	inc hl;
	inc hl;
	res 0, (iy + _flags);
	ld a, d;
	and a;
	jr z, out_line3;
	rst print_a;

org $187d;
out_line2:
	set 0, (iy + _flags);

org $1881;
out_line3:
	push de;
	ex de, hl;
	res 2, (iy + _flags2);
	ld hl, flags;
	res 2, (hl);
	bit 5, (iy + _flagx);
	jr z, out_line4;
	set 2, (hl);

org $1894;
out_line4:
	ld hl, (x_ptr);
	and a;
	sbc hl, de;
	jr nz, out_line5;
	ld a, '?';
	call out_flash;

org $18a1;
out_line5:
	call out_curs;
	ex de, hl;
	ld a, (hl);
	call number;
	inc hl;
	cp ctrl_enter;
	jr z, out_line6;
	ex de, hl;
	call out_char;
	jr out_line4;

org $18b4;
out_line6:
	pop de;
	ret;

org $18b6;
number:
	cp ctrl_number;
	ret nz;
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	ld a, (hl);
	ret;

org $18c1;
out_flash:
	exx;
	ld hl, (attr_t);
	push hl;
	res 7, h;
	set 7, l;
	ld (attr_t), hl;
	ld hl, p_flag;
	ld d, (hl);
	push de;
	ld (hl), 0;
	call print_out;
	pop hl;
	ld (iy + _p_flag), h;
	pop hl;
	ld (attr_t), hl;
	exx;
	ret;

org $18e1;
out_curs:
	ld hl, (k_cur);
	and a;
	sbc hl, de;
	ret nz;
	ld a, (mode);
	rlc a;
	jr z, out_c_1;
	add a, 'C';
	jr out_c_2;

org $18f3;
out_c_1:
	ld hl, flags;
	res 3, (hl);
	ld a, 'K';
	bit 2, (hl);
	jr z, out_c_2;
	set 3, (hl);
	inc a;
	bit 3, (iy + _flags2);
	jr z, out_c_2;
	ld a, 'C';

org $1909;
out_c_2:
	push de;
	call out_flash;
	pop de;
	ret;

org $190f;
ln_fetch:
	ld e, (hl);
	inc hl;
	ld d, (hl);
	push hl;
	ex de, hl;
	inc hl;
	call line_addr;
	call line_no;
	pop hl;

org $191c;
ln_store:
	bit 5, (iy + _flagx);
	ret nz;
	ld (hl), d;
	dec hl;
	ld (hl), e;
	ret;

org $1925;
out_sp_2:
	ld a, e;
	and a;
	ret m;
	jr out_char;

org $192a;
out_sp_no:
	xor a;

org $192b;
out_sp_1:
	add hl, bc;
	inc a;
	jr c, out_sp_1;
	sbc hl, bc;
	dec a;
	jr z, out_sp_2;
	jp out_code;

org $1937;
out_char:
	call numeric;
	jr nc, out_ch_3;
	cp '!';
	jr c, out_ch_3;
	res 2, (iy + _flags);
	cp tk_then;
	jr z, out_ch_3;
	cp ':';
	jr nz, out_ch_1;
	bit 5, (iy + _flagx);
	jr nz, out_ch_2;
	bit 2, (iy + _flags2);
	jr z, out_ch_3;
	jr out_ch_2;

org $195a;
out_ch_1:
	cp '"';
	jr nz, out_ch_2;
	push af;
	ld a, (flags2);
	xor %00000100;
	ld (flags2), a;
	pop af;

org $1968;
out_ch_2:
	set 2, (iy + _flags);

org $196c;
out_ch_3:
	rst print_a;
	ret;

org $196e;
line_addr:
	push hl;
	ld hl, (prog);
	ld d, h;
	ld e, l;

org $1974;
line_ad_1:
	pop bc;
	call cp_lines;
	ret nc;
	push bc;
	call next_one;
	ex de, hl;
	jr line_ad_1;

org $1980;
cp_lines:
	ld a, (hl);
	cp b;
	ret nz;
	inc hl;
	ld a, (hl);
	dec hl;
	cp c;
	ret;
	inc hl;
	inc hl;
	inc hl;

org $198b;
each_stmt:
	ld (ch_add), hl;
	ld c, 0;

org $1990;
each_s_1:
	dec d;
	ret z;
	rst next_char;
	cp e;
	jr nz, each_s_3;
	and a;
	ret;

org $1998;
each_s_2:
	inc hl;
	ld a, (hl);

org $199a;
each_s_3:
	call number;
	ld (ch_add), hl;
	cp '"';
	jr nz, each_s_4;
	dec c;

org $19a5;
each_s_4:
	cp ':';
	jr z, each_s_5;
	cp tk_then;
	jr nz, each_s_6;

org $19ad;
each_s_5:
	bit 0, c;
	jr z, each_s_1;

org $19b1;
each_s_6:
	cp ctrl_enter;
	jr nz, each_s_2;
	dec d;
	scf;
	ret;

org $19b8;
next_one:
	push hl;
	ld a, (hl);
	cp 64;
	jr c, next_o_3;
	bit 5, a;
	jr z, next_o_4;
	add a, a;
	jp m, next_o_1;
	ccf;

org $19c7;
next_o_1:
	ld bc, $0005;
	jr nc, next_o_2;
	ld c, 18;

org $19ce;
next_o_2:
	rla;
	inc hl;
	ld a, (hl);
	jr nc, next_o_2;
	jr next_o_5;

org $19d5;
next_o_3:
	inc hl;

org $19d6;
next_o_4:
	inc hl;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	inc hl;

org $19db;
next_o_5:
	add hl, bc;
	pop de;

org $19dd;
differ:
	and a;
	sbc hl, de;
	ld b, h;
	ld c, l;
	add hl, de;
	ex de, hl;
	ret;

org $19e5;
reclaim_1:
	call differ;

org $19e8;
reclaim_2:
	push bc;
	ld a, b;
	cpl;
	ld b, a;
	ld a, c;
	cpl;
	ld c, a;
	inc bc;
	call pointers;
	ex de, hl;
	pop hl;
	add hl, de;
	push de;
	ldir;
	pop hl;
	ret;

org $19fb;
e_line_no:
	ld hl, (e_line);
	dec hl;
	ld (ch_add), hl;
	rst next_char;
	ld hl, membot;
	ld (stkend), hl;
	call int_to_fp;
	call fp_to_bc;
	jr c, e_l_1;
	ld hl, $d8f0;
	add hl, bc;

org $1a15;
e_l_1:
	jp c, report_c;
	jp set_stk;

org $1a1b;
out_num_1:
	push de;
	push hl;
	xor a;
	bit 7, b;
	jr nz, out_num_4;
	ld h, b;
	ld l, c;
	ld e, 255;
	jr out_num_3;

org $1a28;
out_num_2:
	push de;
	ld d, (hl);
	inc hl;
	ld e, (hl);
	push hl;
	ex de, hl;
	ld e, ' ';

org $1a30;
out_num_3:
	ld bc, $fc18;
	call out_sp_no;
	ld bc, $ff9c;
	call out_sp_no;
	ld c, $f6;
	call out_sp_no;
	ld a, l;

org $1a42;
out_num_4:
	call out_code;
	pop hl;
	pop de;
	ret;

org $1a48;
offst_tbl:
	defb p_def_fn - $;
	defb p_cat - $;
	defb p_format - $;
	defb p_move - $;
	defb p_erase - $;
	defb p_open - $;
	defb p_close - $;
	defb p_merge - $;
	defb p_verify - $;
	defb p_beep - $;
	defb p_circle - $;
	defb p_ink - $;
	defb p_paper - $;
	defb p_flash - $;
	defb p_bright - $;
	defb p_inverse - $;
	defb p_over - $;
	defb p_out - $;
	defb p_lprint - $;
	defb p_llist - $;
	defb p_stop - $;
	defb p_read - $;
	defb p_data - $;
	defb p_restore - $;
	defb p_new - $;
	defb p_border - $;
	defb p_continue - $;
	defb p_dim - $;
	defb p_rem - $;
	defb p_for - $;
	defb p_go_to - $;
	defb p_go_sub - $;
	defb p_input - $;
	defb p_load - $;
	defb p_list - $;
	defb p_let - $;
	defb p_pause - $;
	defb p_next - $;
	defb p_poke - $;
	defb p_print - $;
	defb p_plot - $;
	defb p_run - $;
	defb p_save - $;
	defb p_random - $;
	defb p_if - $;
	defb p_cls - $;
	defb p_draw - $;
	defb p_clear - $;
	defb p_return - $;
	defb p_copy - $;

org $1a7a;
p_let:
	defb var_rqd, '=', expr_num_str;

org $1a7d;
p_go_to:
	defb num_exp, no_f_ops;
	defw go_to;

org $1a81;
p_if:
	defb num_exp, tk_then, var_syn;
	defw fn_if;

org $1a86;
p_go_sub:
	defb num_exp, no_f_ops;
	defw go_sub;

org $1a8a;
p_stop:
	defb no_f_ops;
	defw stop;

org $1a8d;
p_return:
	defb no_f_ops;
	defw return;

org $1a90;
p_for:
	defb chr_var, '=', num_exp, tk_to, num_exp, var_syn;
	defw lfor;

org $1a98;
p_next:
	defb chr_var, no_f_ops;
	defw lnext;

org $1a9c;
p_print:
	defb var_syn;
	defw print;

org $1a9f;
p_input:
	defb var_syn;
	defw input;

org $1aa2;
p_dim:
	defb var_syn;
	defw dim;

org $1aa5;
p_rem:
	defb var_syn;
	defw rem;

org $1aa8;
p_new:
	defb no_f_ops;
	defw new;

org $1aab;
p_run:
	defb num_exp_0;
	defw run;

org $1aae;
p_list:
	defb var_syn;
	defw list;

org $1ab1;
p_poke:
	defb two_c_s_num, no_f_ops;
	defw poke;

org $1ab5;
p_random:
	defb num_exp_0;
	defw randomize;

org $1ab8;
p_continue:
	defb no_f_ops;
	defw continue;

org $1abb;
p_clear:
	defb num_exp_0;
	defw clear;

org $1abe;
p_cls:
	defb no_f_ops;
	defw cls;

org $1ac1;
p_plot:
	defb two_csn_col, no_f_ops;
	defw plot;

org $1ac5;
p_pause:
	defb num_exp, no_f_ops;
	defw pause;

org $1ac9;
p_read:
	defb var_syn;
	defw read;

org $1acc;
p_data:
	defb var_syn;
	defw data;

org $1acf;
p_restore:
	defb num_exp_0;
	defw restore;

org $1ad2;
p_draw:
	defb two_csn_col, var_syn;
	defw draw;

org $1ad6;
p_copy:
	defb no_f_ops;
	defw copy;

org $1ad9;
p_lprint:
	defb var_syn;
	defw lprint;

org $1adc;
p_llist:
	defb var_syn;
	defw llist;

org $1adf;
p_save:
	defb tap_offst;

org $1ae0;
p_load:
	defb tap_offst;

org $1ae1;
p_verify:
	defb tap_offst;

org $1ae2;
p_merge:
	defb tap_offst;

org $1ae3;
p_beep:
	defb no_f_ops;;
	defw beep;

org $1ae7;
p_circle:
	defb two_csn_col, var_syn;
	defw circle;

org $1aeb;
p_ink:
	defb col_offst;

org $1aec;
p_paper:
	defb col_offst;

org $1aed;
p_flash:
	defb col_offst;

org $1aee;
p_bright:
	defb col_offst;

org $1aef;
p_inverse:
	defb col_offst;

org $1af0;
p_over:
	defb col_offst;

org $1af1;
p_out:
	defb two_c_s_num, no_f_ops;
	defw fn_out;

org $1af5;
p_border:
	defb num_exp, no_f_ops;
	defw border;

org $1af9;
p_def_fn:
	defb var_syn;
	defw def_fn;

org $1afc;
p_open:
	defb num_exp, ',', str_exp, no_f_ops;
	defw open;

org $1b02;
p_close:
	defb num_exp, no_f_ops;
	defw close;

org $1b06;
p_format:
	defb str_exp, no_f_ops;
	defw cat_etc;

org $1b0a;
p_move:
	defb str_exp, ',', str_exp, no_f_ops;
	defw cat_etc;

org $1b10;
p_erase:
	defb str_exp, no_f_ops;
	defw cat_etc;

org $1b14;
p_cat:
	defb no_f_ops;
	defw cat_etc;

org $1b17;
line_scan:
	res 7, (iy + _flags);
	call e_line_no;
	xor a;
	ld (subppc), a;
	dec a;
	ld (err_nr), a;
	jr stmt_l_1;

org $1b28;
stmt_loop:
	rst next_char;

org $1b29;
stmt_l_1:
	call set_work;
	inc (iy + _subppc);
	jp m, report_c;
	rst get_char;
	ld b, 0;
	cp ctrl_enter;
	jr z, line_end;
	cp ':';
	jr z, stmt_loop;
	ld hl, stmt_ret;
	push hl;
	ld c, a;
	rst next_char;
	ld a, c;
	sub tk_def_fn;
	jp c, report_c;
	ld c, a;
	ld hl, offst_tbl;
	add hl, bc;
	ld c, (hl);
	add hl, bc;
	jr get_param;

org $1b52;
scan_loop:
	ld hl, (t_addr);

org $1b55;
get_param:
	ld a, (hl);
	inc hl;
	ld (t_addr), hl;
	ld bc, scan_loop;
	push bc;
	ld c, a;
	cp ' ';
	jr nc, separator;
	ld hl, class_tbl;
	ld b, 0;
	add hl, bc;
	ld c, (hl);
	add hl, bc;
	push hl;
	rst get_char;
	dec b;
	ret;

org $1b6f;
separator:
	rst get_char;
	cp c;
	jp nz, report_c;
	rst next_char;
	ret;

org $1b76;
stmt_ret:
	call break_key;
	jr c, stmt_r_1;

org $1b7b;
report_l:
	rst error;
	defb break_into_program;

org $1b7d;
stmt_r_1:
	bit 7, (iy + $0a) ;nsppc;
	jr nz, stmt_next;
	ld hl, (newppc);
	bit 7, h;
	jr z, line_new;

org $1b8a;
line_run:
	ld hl, $fffe;
	ld (ppc), hl;
	ld hl, (worksp);
	dec hl;
	ld de, (e_line);
	dec de;
	ld a, (nsppc);
	jr next_line;

org $1b9e;
line_new:
	call line_addr;
	ld a, (nsppc);
	jr z, line_use;
	and a;
	jr nz, report_n;
	ld b, a;
	ld a, (hl);
	and %11000000;
	ld a, b;
	jr z, line_use;

org $1bb0;
report_0:
	rst error;
	defb ok;

org $1bb2;
rem:
	pop bc;

org $1bb3;
line_end:
	call syntax_z;
	ret z;
	ld hl, (nxtlin);
	ld a, 192;
	and (hl);
	ret nz;
	xor a;

org $1bbf;
line_use:
	cp 1;
	adc a, 0;
	ld d, (hl);
	inc hl;
	ld e, (hl);
	ld (ppc), de;
	inc hl;
	ld e, (hl);
	inc hl;
	ld d, (hl);
	ex de, hl;
	add hl, de;
	inc hl;

org $1bd1;
next_line:
	ld (nxtlin), hl;
	ex de, hl;
	ld (ch_add), hl;
	ld d, a;
	ld e, 0;
	ld (iy + _nsppc), 255;
	dec d;
	ld (iy + _subppc), d;
	jp z, stmt_loop;
	inc d;
	call each_stmt;
	jr z, stmt_next;

org $1bec;
report_n:
	rst error;
	defb statement_lost;

org $1bee;
check_end:
	call syntax_z;
	ret nz;
	pop bc;
	pop bc;

org $1bf4;
stmt_next:
	rst get_char;
	cp ctrl_enter;
	jr z, line_end;
	cp ':';
	jp z, stmt_loop;
	jp report_c;

org $1c01;
class_tbl:
	defb class_00 - $;
	defb class_01 - $;
	defb class_02 - $;
	defb class_03 - $;
	defb class_04 - $;
	defb class_05 - $;
	defb class_06 - $;
	defb class_07 - $;
	defb class_08 - $;
	defb class_09 - $;
	defb class_0a - $;
	defb class_0b - $;

org $1c0d;
class_03:
	call fetch_num;

org $1c10;
class_00:
	cp a;

org $1c11;
class_05:
	pop bc;
	call z, check_end;
	ex de, hl;
	ld hl, (t_addr);
	ld c, (hl);
	inc hl;
	ld b, (hl);
	ex de, hl;
	push bc;
	ret;

org $1c1f;
class_01:
	call look_vars;

org $1c22;
var_a_1:
	ld (iy + _flagx), 0;
	jr nc, var_a_2;
	set 1, (iy + _flagx);
	jr nz, var_a_3;

org $1c2e;
report_2:
	rst error;
	defb variable_not_found;

org $1c30;
var_a_2:
	call z, stk_var;
	bit 6, (iy + _flags);
	jr nz, var_a_3;
	xor a;
	call syntax_z;
	call nz, stk_fetch;
	ld hl, flagx;
	or (hl);
	ld (hl), a;
	ex de, hl;

org $1c46;
var_a_3:
	ld (strlen), bc;
	ld (dest), hl;
	ret;

org $1c4e;
class_02:
	pop bc;
	call val_fet_1;
	call check_end;
	ret;

org $1c56;
val_fet_1:
	ld a, (flags);

org $1c59;
val_fet_2:
	push af;
	call scanning;
	pop af;
	ld d, (iy + _flags);
	xor d;
	and %01000000;
	jr nz, report_c;
	bit 7, d;
	jp nz, let;
	ret;

org $1c6c;
class_04:
	call look_vars;
	push af;
	ld a, c;
	or %10011111;
	inc a;
	jr nz, report_c;
	pop af;
	jr var_a_1;

org $1c79;
next_2num:
	rst next_char;

org $1c7a;
class_08:
expt_2num:
	call expt_1num;
	cp ',';
	jr nz, report_c;
	rst next_char;

org $1c82;
class_06:
expt_1num:
	call scanning;
	bit 6, (iy + _flags);
	ret nz;

org $1c8a;
report_c:
	rst error;
	defb nonsense_in_basic;

org $1c8c;
class_0a:
expt_exp:
	call scanning;
	bit 6, (iy + _flags);
	ret z;
	jr report_c;

org $1c96;
class_07:
	bit 7, (iy + _flags);
	res 0, (iy + _vdu_flag);
	call nz, temps;
	pop af;
	ld a, (t_addr);
	sub low(p_ink - 216);
	call co_temp_4;
	call check_end;
	ld hl, (attr_t);
	ld (attr_p), hl;
	ld hl, p_flag;
	ld a, (hl);
	rlca;
	xor (hl);
	and %10101010;
	xor (hl);
	ld (hl), a;
	ret;

org $1cbe;
class_09:
	call syntax_z;
	jr z, cl_09_1;
	res 0, (iy + _vdu_flag);
	call temps;
	ld hl, mask_t;
	ld a, (hl);
	or %11111000;
	ld (hl), a;
	res 6, (iy + _p_flag);
	rst get_char;

org $1cd6;
cl_09_1:
	call co_temp_2;
	jr expt_2num;

org $1cdb;
class_0b:
;	jp save_etc;

org $1cde;
fetch_num:
	cp ctrl_enter;
	jr z, use_zero;
	cp ':';
	jr nz, expt_1num;

org $1ce6;
use_zero:
	call syntax_z;
	ret z;
	fwait();
	fstk0();
	fce();
	ret;

org $1cee;
report_9:
stop:
	rst error;
	defb stop_statement;

org $1cf0;
fn_if:
	pop bc;
	call syntax_z;
	jr z, if_1;
	fwait();
	fdel();
	fce();
	ex de, hl;
	call test_zero;
	jp c, line_end;

org $1d00;
if_1:
	jp stmt_l_1;

org $1d03;
lfor:
	cp tk_step;
	jr nz, f_use_1;
	rst next_char;
	call expt_1num;
	call check_end;
	jr f_reorder;

org $1d10;
f_use_1:
	call check_end;
	fwait();
	fstk1();
	fce();

org $1d16;
f_reorder:
	fwait();
	fst(0);
	fdel();
	fxch();
	fgt(0);
	fxch();
	fce();
	call let;
	ld (mem), hl;
	dec hl;
	ld a, (hl);
	set 7, (hl);
	ld bc, $0006;
	add hl, bc;
	rlca;
	jr c, f_l_s;
	ld c, 13;
	call make_room;
	inc hl;

org $1d34;
f_l_s:
	push hl;
	fwait();
	fdel();
	fdel();
	fce();
	pop hl;
	ex de, hl;
	ld c, 10;
	ldir;
	ld hl, (ppc);
	ex de, hl;
	ld (hl), e;
	inc hl;
	ld (hl), d;
	ld d, (iy + _subppc);
	inc d;
	inc hl;
	ld (hl), d;
	call next_loop;
	ret nc;
	ld b, (iy + $38) ;strlen_lo;
	ld hl, (ppc);
	ld (newppc), hl;
	ld a, (subppc);
	neg;
	ld d, a;
	ld hl, (ch_add);
	ld e, tk_next;

org $1d64;
f_loop:
	push bc;
	ld bc, (nxtlin);
	call look_prog;
	ld (nxtlin), bc;
	pop bc;
	jr c, report_i;
	rst next_char;
	or %00100000;
	cp b;
	jr z, f_found;
	rst next_char;
	jr f_loop;

org $1d7c;
f_found:
	rst next_char;
	ld a, 1;
	sub d;
	ld (nsppc), a;
	ret;

org $1d84;
report_i:
	rst error;
	defb for_without_next;

org $1d86;
look_prog:
	ld a, (hl);
	cp ':';
	jr z, look_p_2;

org $1d8b;
look_p_1:
	inc hl;
	ld a, (hl);
	and %11000000;
	scf;
	ret nz;
	ld b, (hl);
	inc hl;
	ld c, (hl);
	ld (newppc), bc;
	inc hl;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	push hl;
	add hl, bc;
	ld b, h;
	ld c, l;
	pop hl;
	ld d, 0;

org $1da3;
look_p_2:
	push bc;
	call each_stmt;
	pop bc;
	ret nc;
	jr look_p_1;

org $1dab;
lnext:
	bit 1, (iy + _flagx);
	jp nz, report_2;
	ld hl, (dest);
	bit 7, (hl);
	jr z, report_1;
	inc hl;
	ld (mem), hl;
	fwait();
	fgt(0);
	fgt(2);
	fadd();
	fst(0);
	fdel();
	fce();
	call next_loop;
	ret c;
	ld hl, (mem);
	ld de, $000f;
	add hl, de;
	ld e, (hl);
	inc hl;
	ld d, (hl);
	inc hl;
	ld h, (hl);
	ex de, hl;
	jp go_to_2;

org $1dd8;
report_1:
	rst error;
	defb next_without_for;

org $1dda;
next_loop:
	fwait();
	fgt(1);
	fgt(0);
	fgt(2);
	fcp(_lz);
	fjpt(next_1);
	fxch();

org $1de2;
next_1:
	fsub();
	fcp(_gz);
	fjpt(next_2);
	fce();
	and a;
	ret;

org $1de9;
next_2:
	fce();
	scf;
	ret;

org $1dec;
read_3:
	rst next_char;

org $1ded;
read:
	call class_01;
	call syntax_z;
	jr z, read_2;
	rst get_char;
	ld (x_ptr), hl;
	ld hl, (datadd);
	ld a, (hl);
	cp 44;
	jr z, read_1;
	ld e, tk_data;
	call look_prog;
	jr nc, read_1;

org $1e08;
report_e:
	rst error;
	defb out_of_data;

org $1e0a;
read_1:
	call temp_ptr1;
	call val_fet_1;
	rst get_char;
	ld (datadd), hl;
	ld hl, (x_ptr);
	ld (iy + _x_ptr_h), 0;
	call temp_ptr2;

org $1e1e;
read_2:
	rst get_char;
	cp 44;
	jr z, read_3;
	call check_end;
	ret;

org $1e27;
data:
	call syntax_z;
	jr nz, data_2;

org $1e2c;
data_1:
	call scanning;
	cp 44;
	call nz, check_end;
	rst next_char;
	jr data_1;

org $1e37;
data_2:
	ld a, tk_data;

org $1e39;
pass_by:
	ld b, a;
	cpdr;
	ld de, $0200;
	jp each_stmt;

org $1e42;
restore:
	call find_int2;

org $1e45;
rest_run:
	ld h, b;
	ld l, c;
	call line_addr;
	dec hl;
	ld (datadd), hl;
	ret;

org $1e4f;
randomize:
	call find_int2;
	ld a, b;
	or c;
	jr nz, rand_1;
	ld bc, (frames);

org $1e5a;
rand_1:
	ld (seed), bc;
	ret;

org $1e5f;
continue:
	ld hl, (oldppc);
	ld d, (iy + _osppc);
	jr go_to_2;

org $1e67;
go_to:
	call find_int2;
	ld h, b;
	ld l, c;
	ld d, 0;
	ld a, h;
	cp 240;
	jr nc, report_bb;

org $1e73;
go_to_2:
	ld (newppc), hl;
	ld (iy + $0a), d;
	ret;

org $1e7a;
fn_out:
	call two_param;
	out (c), a;
	ret;

org $1e80;
poke:
	call two_param;
	ld (bc), a;
	ret;

org $1e85;
two_param:
	call fp_to_a;
	jr c, report_bb;
	jr z, two_p_1;
	neg;

org $1e8e;
two_p_1:
	push af;
	call find_int2;
	pop af;
	ret;

org $1e94;
find_int1:
	call fp_to_a;
	jr find_i_1;

org $1e99;
find_int2:
	call fp_to_bc;

org $1e9c;
find_i_1:
	jr c, report_bb;
	ret z;

org $1e9f;
report_bb:
	rst error;
	defb integer_out_of_range;

org $1ea1;
run:
	call go_to;
	ld bc, $0000;
	call rest_run;
	jr clear_run;

org $1eac;
clear:
	call find_int2;

org $1eaf;
clear_run:
	ld a, b;
	or c;
	jr nz, clear_1;
	ld bc, (ramtop);

org $1eb7;
clear_1:
	push bc;
	ld de, (vars);
	ld hl, (e_line);
	dec hl;
	call reclaim_1;
	call cls;
	ld hl, (stkend);
	ld de, $0032;
	add hl, de;
	pop de;
	sbc hl, de;
	jr nc, report_m;
	ld hl, (p_ramt);
	and a;
	sbc hl, de;
	jr nc, clear_2;

org $1eda;
report_m:
	rst error;
	defb ramtop_no_good;

org $1edc;
clear_2:
	ex de, hl;
	ld (ramtop), hl;
	pop de;
	pop bc;
	ld (hl), $3e;
	dec hl;
	ld sp, hl;
	push bc;
	ld (err_sp), sp;
	ex de, hl;
	jp (hl);

org $1eed;
go_sub:
	pop de;
	ld h, (iy + _subppc);
	inc h;
	ex (sp), hl;
	inc sp;
	ld bc, (ppc);
	push bc;
	push hl;
	ld (err_sp), sp;
	push de;
	call go_to;
	ld bc, $0014;

org $1f05;
test_room:
	ld hl, (stkend);
	add hl, bc;
	jr c, report_4;
	ex de, hl;
	ld hl, $0050;
	add hl, de;
	jr c, report_4;
	sbc hl, sp;
	ret c;

org $1f15;
report_4:
	ld l, 3;
	jp error_3;

org $1f1a;
free_mem:
	ld bc, $0000;
	call test_room;
	ld b, h;
	ld c, l;
	ret;

org $1f23;
return:
	pop bc;
	pop hl;
	pop de;
	ld a, d;
	cp $3e;
	jr z, report_7;
	dec sp;
	ex (sp), hl;
	ex de, hl;
	ld (err_sp), sp;
	push bc;
	jp go_to_2;

org $1f36;
report_7:
	push de;
	push hl;
	rst error;
	defb return_without_gosub;

org $1f3a;
pause:
	call find_int2;

org $1f3d;
pause_1:
	halt;
	dec bc;
	ld a, b;
	or c;
	jr z, pause_end;
	ld a, b;
	and c;
	inc a;
	jr nz, pause_2;
	inc bc;

org $1f49;
pause_2:
	bit 5, (iy + _flags);
	jr z, pause_1;

org $1f4f;
pause_end:
	res 5, (iy + _flags);
	ret;

org $1f54;
break_key:
	ld a, 127;
	in a, (ula);
	rra;
	ret c;
	ld a, 254;
	in a, (ula);
	rra;
	ret;

org $1f60;
def_fn:
	call syntax_z;
	jr z, def_fn_1;
	ld a, tk_def_fn;
	jp pass_by;

org $1f6a;
def_fn_1:
	set 6, (iy + _flags);
	call alpha;
	jr nc, def_fn_4;
	rst next_char;
	cp '$';
	jr nz, def_fn_2;
	res 6, (iy + _flags);
	rst next_char;

org $1f7d;
def_fn_2:
	cp '(';
	jr nz, def_fn_7;
	rst next_char;
	cp ')';
	jr z, def_fn_6;

org $1f86;
def_fn_3:
	call alpha;

org $1f89;
def_fn_4:
	jp nc, report_c;
	ex de, hl;
	rst next_char;
	cp '$';
	jr nz, def_fn_5;
	ex de, hl;
	rst next_char;

org $1f94;
def_fn_5:
	ex de, hl;
	ld bc, $0006;
	call make_room;
	inc hl;
	inc hl;
	ld (hl), ctrl_number;
	cp ',';
	jr nz, def_fn_6;
	rst next_char;
	jr def_fn_3;

org $1fa6;
def_fn_6:
	cp ')';
	jr nz, def_fn_7;
	rst next_char;
	cp '=';
	jr nz, def_fn_7;
	rst next_char;
	ld a, (flags);
	push af;
	call scanning;
	pop af;
	xor (iy + _flags);
	and %01000000;

org $1fbd;
def_fn_7:
	jp nz, report_c;
	call check_end;

org $1fc3;
unstack_z:
	call syntax_z;
	pop hl;
	ret z;
	jp (hl);

org $1fc9;
lprint:
	ld a, 3;
	jr print_1;

org $1fcd;
print:
	ld a, 2;

org $1fcf;
print_1:
	call syntax_z;
	call nz, chan_open;
	call temps;
	call print_2;
	call check_end;
	ret;

org $1fdf;
print_2:
	rst get_char;
	call pr_end_z;
	jr z, print_4;

org $1fe5;
print_3:
	call pr_posn_1;
	jr z, print_3;
	call pr_item_1;
	call pr_posn_1;
	jr z, print_3;

org $1ff2;
print_4:
	cp ')';
	ret z;

org $1ff5;
print_cr:
	call unstack_z;
	ld a, ctrl_enter;
	rst print_a;
	ret;

org $1ffc;
pr_item_1:
	rst get_char;
	cp tk_at;
	jr nz, pr_item_2;
	call next_2num;
	call unstack_z;
	call stk_to_bc;
	ld a, ctrl_at;
	jr pr_at_tab;

org $200e;
pr_item_2:
	cp tk_tab;
	jr nz, pr_item_3;
	rst next_char;
	call expt_1num;
	call unstack_z;
	call find_int2;
	ld a, ctrl_tab;

org $201e;
pr_at_tab:
	rst print_a;
	ld a, c;
	rst print_a;
	ld a, b;
	rst print_a;
	ret;

org $2024;
pr_item_3:
	call co_temp_3;
	ret nc;
	call str_alter;
	ret nc;
	call scanning;
	call unstack_z;
	bit 6, (iy + _flags);
	call z, stk_fetch;
	jp nz, print_fp;

org $203c;
pr_string:
	ld a, b;
	or c;
	dec bc;
	ret z;
	ld a, (de);
	inc de;
	rst print_a;
	jr pr_string;

org $2045;
pr_end_z:
	cp ')';
	ret z;

org $2048;
pr_st_end:
	cp ctrl_enter;
	ret z;
	cp ':';
	ret;

org $204e;
pr_posn_1:
	rst get_char;
	cp ';';
	jr z, pr_posn_3;
	cp ',';
	jr nz, pr_posn_2;
	call syntax_z;
	jr z, pr_posn_3;
	ld a, ctrl_comma;
	rst print_a;
	jr pr_posn_3;

org $2061;
pr_posn_2:
	cp "'";
	ret nz;
	call print_cr;

org $2067;
pr_posn_3:
	rst next_char;
	call pr_end_z;
	jr nz, pr_posn_4;
	pop bc;

org $206e;
pr_posn_4:
	cp a;
	ret;

org $2070;
str_alter:
	cp '#';
	scf;
	ret nz;
	rst next_char;
	call expt_1num;
	and a;
	call unstack_z;
	call find_int1;
	cp 16;
	jp nc, report_oa;
	call chan_open;
	and a;
	ret;

org $2089;
input:
	call syntax_z;
	jr z, input_1;
	ld a, 1;
	call chan_open;
	call cls_lower;

org $2096;
input_1:
	ld (iy + _vdu_flag), $01;
	call in_item_1;
	call check_end;
	ld bc, (s_posn);
	ld a, (df_sz);
	cp b;
	jr c, input_2;
	ld c, 33;
	ld b, a;

org $20ad;
input_2:
	ld (s_posn), bc;
	ld a, 25;
	sub b;
	ld (scr_ct), a;
	res 0, (iy + _vdu_flag);
	call cl_set;
	jp cls_lower;

org $20c1;
in_item_1:
	call pr_posn_1;
	jr z, in_item_1;
	cp '(';
	jr nz, in_item_2;
	rst next_char;
	call print_2;
	rst get_char;
	cp ')';
	jp nz, report_c;
	rst next_char;
	jp in_next_2;

org $20d8;
in_item_2:
	cp tk_line;
	jr nz, in_item_3;
	rst next_char;
	call class_01;
	set 7, (iy + _flagx);
	bit 6, (iy + _flags);
	jp nz, report_c;
	jr in_prompt;

org $20ed;
in_item_3:
	call alpha;
	jp nc, in_next_1;
	call class_01;
	res 7, (iy + _flagx);

org $20fa;
in_prompt:
	call syntax_z;
	jp z, in_next_2;
	call set_work;
	ld hl, flagx;
	res 6, (hl);
	set 5, (hl);
	ld bc, $0001;
	bit 7, (hl) ;flagx;
	jr nz, in_pr_2;
	ld a, (flags);
	and %01000000;
	jr nz, in_pr_1;
	ld c, 3;

org $211a;
in_pr_1:
	or (hl);
	ld (hl), a;

org $211c;
in_pr_2:
	rst bc_spaces;
	ld (hl), ctrl_enter;
	ld a, c;
	rrca;
	rrca;
	jr nc, in_pr_3;
	ld a, '"';
	ld (de), a;
	dec hl;
	ld (hl), a;

org $2129;
in_pr_3:
	ld (k_cur), hl;
	bit 7, (iy + _flagx);
	jr nz, in_var_3;
	ld hl, (ch_add);
	push hl;
	ld hl, (err_sp);
	push hl;

org $213a;
in_var_1:
	ld hl, in_var_1;
	push hl;
	bit 4, (iy + _flags2);
	jr z, in_var_2;
	ld (err_sp), sp;

org $2148;
in_var_2:
	ld hl, (worksp);
	call remove_fp;
	ld (iy + _err_nr), 255;
	call editor;
	res 7, (iy + _flags);
	call in_assign;
	jr in_var_4;

org $215e;
in_var_3:
	call editor;

org $2161;
in_var_4:
	ld (iy + _k_cur_h), 0;
	call in_chan_k;
	jr nz, in_var_5;
	call ed_copy;
	ld bc, (echo_e);
	call cl_set;

org $2174;
in_var_5:
	ld hl, flagx;
	res 5, (hl);
	bit 7, (hl);
	res 7, (hl);
	jr nz, in_var_6;
	pop hl;
	pop hl;
	ld (err_sp), hl;
	pop hl;
	ld (x_ptr), hl;
	set 7, (iy + _flags);
	call in_assign;
	ld hl, (x_ptr);
	ld (iy + _x_ptr_h), 0;
	ld (ch_add), hl;
	jr in_next_2;

org $219b;
in_var_6:
	ld hl, (stkbot);
	ld de, (worksp);
	scf;
	sbc hl, de;
	ld b, h;
	ld c, l;
	call stk_sto_str;
	call let;
	jr in_next_2;

org $21af;
in_next_1:
	call pr_item_1;

org $21b2;
in_next_2:
	call pr_posn_1;
	jp z, in_item_1;
	ret;

org $21b9;
in_assign:
	ld hl, (worksp);
	ld (ch_add), hl;
	rst get_char;
	cp tk_stop;
	jr z, in_stop;
	ld a, (flagx);
	call val_fet_2;
	rst get_char;
	cp ctrl_enter;
	ret z;

org $21ce;
report_cb:
	rst error;
	defb nonsense_in_basic;

org $21d0;
in_stop:
	call syntax_z;
	ret z;

org $21d4;
report_h:
	rst error;
	defb stop_in_input;

org $21d6;
in_chan_k:
	ld hl, (curchl);
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	ld a, (hl);
	cp 'K';
	ret;

org $21e1;
co_temp_1:
	rst next_char;

org $21e2;
co_temp_2:
	call co_temp_3;
	ret c;
	rst get_char;
	cp ',';
	jr z, co_temp_1;
	cp ';';
	jr z, co_temp_1;
	jp report_c;

org $21f2;
co_temp_3:
	cp tk_ink;
	ret c;
	cp tk_out;
	ccf;
	ret c;
	push af;
	rst next_char;
	pop af;

org $21fc;
co_temp_4:
	sub 201;
	push af;
	call expt_1num;
	pop af;
	and a;
	call unstack_z;
	push af;
	call find_int1;
	ld d, a;
	pop af;
	rst print_a;
	ld a, d;
	rst print_a;
	ret;

org $2211;
co_temp_5:
	sub 17;
	adc a, 0;
	jr z, co_temp_7;
	sub 2;
	adc a, 0;
	jr z, co_temp_c;
	cp 1;
	ld a, d;
	ld b, 1;
	jr nz, co_temp_6;
	rlca;
	rlca;
	ld b, 4;

org $2228;
co_temp_6:
	ld c, a;
	ld a, d;
	cp 2;
	jr nc, report_k;
	ld a, c;
	ld hl, p_flag;
	jr co_change;

org $2234;
co_temp_7:
	ld a, d;
	ld b, %00000111;
	jr c, co_temp_8;
	rlca;
	rlca;
	rlca;
	ld b, %00111000;

org $223e;
co_temp_8:
	ld c, a;
	ld a, d;
	cp 10;
	jr c, co_temp_9;

org $2244;
report_k:
	rst error;
	defb invalid_colour;

org $2246;
co_temp_9:
	ld hl, attr_t;
	cp 8;
	jr c, co_temp_b;
	ld a, (hl);
	jr z, co_temp_a;
	or b;
	cpl;
	and %00100100;
	jr z, co_temp_a;
	ld a, b;

org $2257;
co_temp_a:
	ld c, a;

org $2258;
co_temp_b:
	ld a, c;
	call co_change;
	ld a, 7;
	cp d;
	sbc a, a;
	call co_change;
	rlca;
	rlca;
	and %01010000;
	ld b, a;
	ld a, 8;
	cp d;
	sbc a, a;

org $226c;
co_change:
	xor (hl);
	and b;
	xor (hl);
	ld (hl), a;
	inc hl;
	ld a, b;
	ret;

org $2273;
co_temp_c:
	sbc a, a;
	ld a, d;
	rrca;
	ld b, %10000000;
	jr nz, co_temp_d;
	rrca;
	ld b, %01000000;

org $227d;
co_temp_d:
	ld c, a;
	ld a, d;
	cp 8;
	jr z, co_temp_e;
	cp 2;
	jr nc, report_k;

org $2287;
co_temp_e:
	ld a, c;
	ld hl, attr_t;
	call co_change;
	ld a, c;
	rrca;
	rrca;
	rrca;
	jr co_change;

org $2294;
border:
	call find_int1;
	cp 8;
	jr nc, report_k;
	out (ula), a;
	rlca;
	rlca;
	rlca;
	bit 5, a;
	jr nz, border_1;
	xor %00000111;

org $22a6;
border_1:
	ld (bordcr), a;
	ret;

org $22aa;
pixel_add:
	ld a, 175;
	sub b;
	jp c, report_bc;
	ld b, a;
	and a;
	rra;
	scf;
	rra;
	and a;
	rra;
	xor b;
	and %11111000;
	xor b;
	ld h, a;
	ld a, c;
	rlca;
	rlca;
	rlca;
	xor b;
	and %11000111;
	xor b;
	rlca;
	rlca;
	ld l, a;
	ld a, c;
	and %00000111;
	ret;

org $22cb;
point_sub:
	call stk_to_bc;
	call pixel_add;
	ld b, a;
	inc b;
	ld a, (hl);

org $22d4;
point_lp:
	rlca;
	djnz point_lp;
	and %00000001;
	jp stack_a;

org $22dc;
plot:
	call stk_to_bc;
	call plot_sub;
	jp temps;

org $22e5;
plot_sub:
	ld (coords), bc;
	call pixel_add;
	ld b, a;
	inc b;
	ld a, %11111110;

org $22f0;
plot_loop:
	rrca;
	djnz plot_loop;
	ld b, a;
	ld a, (hl);
	ld c, (iy + _p_flag);
	bit 0, c;
	jr nz, pl_tst_in;
	and b;

org $22fd;
pl_tst_in:
	bit 2, c;
	jr nz, plot_end;
	xor b;
	cpl;

org $2303;
plot_end:
	ld (hl), a;
	jp po_attr;

org $2307;
stk_to_bc:
	call stk_to_a;
	ld b, a;
	push bc;
	call stk_to_a;
	ld e, c;
	pop bc;
	ld d, c;
	ld c, a;
	ret;

org $2314;
stk_to_a:
	call fp_to_a;
	jp c, report_bc;
	ld c, 1;
	ret z;
	ld c, 255;
	ret;

org $2320;
circle:
	rst get_char;
	cp ',';
	jp nz, report_c;
	rst next_char;
	call expt_1num;
	call check_end;
	fwait();
	fabs();
	frstk();
	fce();
	ld a, (hl);
	cp 129;
	jr nc, c_r_gre_1;
	fwait();
	fdel();
	fce();
	jr plot;

org $233b;
c_r_gre_1:
	fwait();
	fstkhalfpi();
	fce();
	ld (hl), 131;
	fwait();
	fst(5);
	fdel();
	fce();
	call cd_prms1;
	push bc;
	fwait();
	fmove();
	fgt(1);
	fmul();
	fce();
	ld a, (hl);
	cp 128;
	jr nc, c_arc_ge1;
	fwait();
	fdel();
	fdel();
	fce();
	pop bc;
	jp plot;

org $235a;
c_arc_ge1:
	fwait();
	fst(2);
	fxch();
	fst(0);
	fdel();
	fsub();
	fxch();
	fgt(0);
	fadd();
	fst(0);
	fxch();
	fmove();
	fgt(0);
	fxch();
	fmove();
	fgt(0);
	fstk0();
	fst(1);
	fdel();
	fce();
	inc (iy + _mem_2);
	call find_int1;
	ld l, a;
	push hl;
	call find_int1;
	pop hl;
	ld h, a;
	ld (coords), hl;
	pop bc;
	jp drw_steps;

org $2382;
draw:
	rst get_char;
	cp ',';
	jr z, dr_3_prms;
	call check_end;
	jp line_draw;

org $238d;
dr_3_prms:
	rst next_char;
	call expt_1num;
	call check_end;
	fwait();
	fst(5);
	fstkhalf();
	fmul();
	fsin();
	fmove();
	fnot();
	fnot();
	fjpt(dr_sin_nz);
	fdel();
	fce();
	jp line_draw;

org $23a3;
dr_sin_nz:
	fst(0);
	fdel();
	fst(1);
	fdel();
	fmove();
	fabs();
	fgt(1);
	fxch();
	fgt(1);
	fabs();
	fadd();
	fgt(0);
	fdiv();
	fabs();
	fgt(0);
	fxch();
	frstk();
	fce();
	ld a, (hl);
	cp 129;
	jr nc, dr_prms;
	fwait();
	fdel();
	fdel();
	fce();
	jp line_draw;

org $23c1;
dr_prms:
	call cd_prms1;
	push bc;
	fwait();
	fdel();
	fgt(1);
	fxch();
	fdiv();
	fst(1);
	fdel();
	fxch();
	fmove();
	fgt(1);
	fmul();
	fst(2);
	fdel();
	fxch();
	fmove();
	fgt(1);
	fmul();
	fgt(2);
	fgt(5);
	fgt(0);
	fsub();
	fstkhalf();
	fmul();
	fmove();
	fsin();
	fst(5);
	fdel();
	fcos();
	fst(0);
	fdel();
	fst(2);
	fdel();
	fst(1);
	fgt(5);
	fmul();
	fgt(0);
	fgt(2);
	fmul();
	fadd();
	fgt(1);
	fxch();
	fst(1);
	fdel();
	fgt(0);
	fmul();
	fgt(2);
	fgt(5);
	fmul();
	fsub();
	fst(2);
	fabs();
	fgt(1);
	fabs();
	fadd();
	fdel();
	fce();
	ld a, (de);
	cp 129;
	pop bc;
	jp c, line_draw;
	push bc;
	fwait();
	fxch();
	fce();
	ld a, (coords);
	call stack_a;
	fwait();
	fst(0);
	fadd();
	fxch();
	fce();
	ld a, (coord_y);
	call stack_a;
	fwait();
	fst(5);
	fadd();
	fgt(0);
	fgt(5);
	fce();
	pop bc;

org $2420;
drw_steps:
	dec b;
	jr z, arc_end;
	jr arc_start;

org $2425;
arc_loop:
	fwait();
	fgt(1);
	fmove();
	fgt(3);
	fmul();
	fgt(2);
	fgt(4);
	fmul();
	fsub();
	fst(1);
	fdel();
	fgt(4);
	fmul();
	fgt(2);
	fgt(3);
	fmul();
	fadd();
	fst(2);
	fdel();
	fce();

org $2439;
arc_start:
	push bc;
	fwait();
	fst(0);
	fdel();
	fgt(1);
	fadd();
	fmove();
	fce();
	ld a, (coords);
	call stack_a;
	fwait();
	fsub();
	fgt(0);
	fgt(2);
	fadd();
	fst(0);
	fxch();
	fgt(0);
	fce();
	ld a, (coord_y);
	call stack_a;
	fwait();
	fsub();
	fce();
	call draw_line;
	pop bc;
	djnz arc_loop;

org $245f;
arc_end:
	fwait();
	fdel();
	fdel();
	fxch();
	fce();
	ld a, (coords);
	call stack_a;
	fwait();
	fsub();
	fxch();
	fce();
	ld a, (coord_y);
	call stack_a;
	fwait();
	fsub();
	fce();

org $2477;
line_draw:
	call draw_line;
	jp temps;

org $247d;
cd_prms1:
	fwait();
	fmove();
	fsqrt();
	fstk();
	defb $32, $00;
	fxch();
	fdiv();
	fgt(5);
	fxch();
	fdiv();
	fabs();
	fce();
	call fp_to_a;
	jr c, use_252;
	and 252;
	add a, 4;
	jr nc, draw_save;

org $2495;
use_252:
	ld a, 252;

org $2497;
draw_save:
	push af;
	call stack_a;
	fwait();
	fgt(5);
	fxch();
	fdiv();
	fmove();
	fsin();
	fst(4);
	fdel();
	fmove();
	fstkhalf();
	fmul();
	fsin();
	fst(1);
	fxch();
	fst(0);
	fdel();
	fmove();
	fmul();
	fmove();
	fadd();
	fstk1();
	fsub();
	fneg();
	fst(3);
	fdel();
	fce();
	pop bc;
	ret;

org $24b7;
draw_line:
	call stk_to_bc;
	ld a, c;
	cp b;
	jr nc, dl_x_ge_y;
	ld l, c;
	push de;
	xor a;
	ld e, a;
	jr dl_larger;

org $24c4;
dl_x_ge_y:
	or c;
	ret z;
	ld l, b;
	ld b, c;
	push de;
	ld d, 0;

org $24cb;
dl_larger:
	ld h, b;
	ld a, b;
	rra;

org $24ce;
d_l_loop:
	add a, l;
	jr c, d_l_diag;
	cp h;
	jr c, d_l_hr_vt;

org $24d4;
d_l_diag:
	sub h;
	ld c, a;
	exx;
	pop bc;
	push bc;
	jr d_l_step;

org $24db;
d_l_hr_vt:
	ld c, a;
	push de;
	exx;
	pop bc;

org $24df;
d_l_step:
	ld hl, (coords);
	ld a, b;
	add a, h;
	ld b, a;
	ld a, c;
	inc a;
	add a, l;
	jr c, d_l_range;
	jr z, report_bc;

org $24ec;
d_l_plot:
	dec a;
	ld c, a;
	call plot_sub;
	exx;
	ld a, c;
	djnz d_l_loop;
	pop de;
	ret;

org $24f7;
d_l_range:
	jr z, d_l_plot;

org $24f9;
report_bc:
	rst error;
	defb integer_out_of_range;

org $24fb;
scanning:
	rst get_char;
	ld b, 0;
	push bc;

org $24ff;
s_loop_1:
	ld c, a;
	ld hl, scan_func;
	call indexer;
	ld a, c;
	jp nc, s_alphnum;
	ld b, 0;
	ld c, (hl);
	add hl, bc;
	jp (hl);

org $250f;
s_quote_s:
	call ch_add_plus_1;
	inc bc;
	cp ctrl_enter;
	jp z, report_c;
	cp '"';
	jr nz, s_quote_s;
	call ch_add_plus_1;
	cp '"';
	ret;

org $2522;
s_2_coord:
	rst next_char;
	cp '(';
	jr nz, s_rport_c;
	call next_2num;
	rst get_char;
	cp ')';

org $252d;
s_rport_c:
	jp nz, report_c;

org $2530;
syntax_z:
	bit 7, (iy + _flags);
	ret;

org $2535;
s_scrn_str_s:
	call stk_to_bc;
	ld hl, (chars);
	ld de, $0100;
	add hl, de;
	ld a, c;
	rrca;
	rrca;
	rrca;
	and %11100000;
	xor b;
	ld e, a;
	ld a, c;
	and %00011000;
	xor %01000000;
	ld d, a;
	ld b, 96;

org $254f;
s_scrn_lp:
	push bc;
	push de;
	push hl;
	ld a, (de);
	xor (hl);
	jr z, s_sc_mtch;
	inc a;
	jr nz, s_scr_nxt;
	dec a;

org $255a;
s_sc_mtch:
	ld c, a;
	ld b, 7;

org $255d;
s_sc_rows:
	inc d;
	inc hl;
	ld a, (de);
	xor (hl);
	xor c;
	jr nz, s_scr_nxt;
	djnz s_sc_rows;
	pop bc;
	pop bc;
	pop bc;
	ld a, $80;
	sub b;
	ld bc, $0001;
	rst bc_spaces;
	ld (de), a;
	jr s_scr_sto;

org $2573;
s_scr_nxt:
	pop hl;
	ld de, $0008;
	add hl, de;
	pop de;
	pop bc;
	djnz s_scrn_lp;
	ld c, b;

org $257d;
s_scr_sto:
	jp stk_sto_str;

org $2580;
s_attr_s:
	call stk_to_bc;
	ld a, c;
	rrca;
	rrca;
	rrca;
	ld c, a;
	and %11100000;
	xor b;
	ld l, a;
	ld a, c;
	and %00000011;
	xor %01011000;
	ld h, a;
	ld a, (hl);
	jp stack_a;

org $2596;
scan_func:
	defb '"', s_quote - 1 - $;
	defb '(', s_bracket - 1 - $;
	defb '.', s_decimal - 1 - $;
	defb '+', s_u_plus - 1 - $;
	defb tk_fn, s_fn - 1 - $;
	defb tk_rnd, s_rnd - 1 - $;
	defb tk_pi, s_pi - 1 - $;
	defb tk_inkey_str, s_inkey_str - 1 - $;
	defb tk_bin, s_bin - 1 - $;
	defb tk_screen_str, s_screen_str - 1 - $;
	defb tk_attr, s_attr - 1 - $;
	defb tk_point, s_point - 1 - $;
	defb $00;

org $25af;
s_u_plus:
	rst next_char;
	jp s_loop_1;

org $25b3;
s_quote:
	rst get_char;
	inc hl;
	push hl;
	ld bc, $0000;
	call s_quote_s;
	jr nz, s_q_prms;

org $25be;
s_q_again:
	call s_quote_s;
	jr z, s_q_again;
	call syntax_z;
	jr z, s_q_prms;
	rst bc_spaces;
	pop hl;
	push de;

org $25cb;
s_q_copy:
	ld a, (hl);
	inc hl;
	ld (de), a;
	inc de;
	cp '"';
	jr nz, s_q_copy;
	ld a, (hl);
	inc hl;
	cp '"';
	jr z, s_q_copy;

org $25d9;
s_q_prms:
	dec bc;
	pop de;

org $25db;
s_string:
	ld hl, flags;
	res 6, (hl);
	bit 7, (hl);
	call nz, stk_sto_str;
	jp s_cont_2;

org $25e8;
s_bracket:
	rst next_char;
	call scanning;
	cp ')';
	jp nz, report_c;
	rst next_char;
	jp s_cont_2;

org $25f5;
s_fn:
	jp s_fn_sbrn;

org $25f8;
s_rnd:
	call syntax_z;
	jr z, s_rnd_end;
	ld bc, (seed);
	call stack_bc;
	fwait();
	fstk1();
	fadd();
	fstk();
	defb $37, $16;
	fmul();
	fstk();
	defb $80, $41, $00, $00, $80;
	fmod();
	fdel();
	fstk1();
	fsub();
	fmove();
	fce();
	call fp_to_bc;
	ld (seed), bc;
	ld a, (hl);
	and a;
	jr z, s_rnd_end;
	sub 16;
	ld (hl), a;

org $2625;
s_rnd_end:
	jr s_pi_end;

org $2627;
s_pi:
	call syntax_z;
	jr z, s_pi_end;
	fwait();
	fstkhalfpi();
	fce();
	inc (hl);

org $2630;
s_pi_end:
	rst next_char;
	jp s_numeric;

org $2634;
s_inkey_str:
	ld bc, $105a;
	rst next_char;
	cp '#';
	jp z, s_push_po;
	ld hl, flags;
	res 6, (hl);
	bit 7, (hl);
	jr z, s_ink_str_en;
	call key_scan;
	ld c, 0;
	jr nz, s_ik_str_stk;
	call k_test;
	jr nc, s_ik_str_stk;
	dec d;
	ld e, a;
	call k_decode;
	push af;
	ld bc, $0001;
	rst bc_spaces;
	pop af;
	ld (de), a;
	ld c, 1;

org $2660;
s_ik_str_stk:
	ld b, 0;
	call stk_sto_str;

org $2665;
s_ink_str_en:
	jp s_cont_2;

org $2668;
s_screen_str:
	call s_2_coord;
	call nz, s_scrn_str_s;
	rst next_char;
	jp s_string;

org $2672;
s_attr:
	call s_2_coord;
	call nz, s_attr_s;
	rst next_char;
	jr s_numeric;

org $267b;
s_point:
	call s_2_coord;
	call nz, point_sub;
	rst next_char;
	jr s_numeric;

org $2684;
s_alphnum:
	call alphanum;
	jr nc, s_negate;
	cp 'A';
	jr nc, s_letter;

org $268d;
s_bin:
s_decimal:
	call syntax_z;
	jr nz, s_stk_dec;
	call dec_to_fp;
	rst get_char;
	ld bc, $0006;
	call make_room;
	inc hl;
	ld (hl), ctrl_number;
	inc hl;
	ex de, hl;
	ld hl, (stkend);
	ld c, 5;
	and a;
	sbc hl, bc;
	ld (stkend), hl;
	ldir;
	ex de, hl;
	dec hl;
	call temp_ptr1;
	jr s_numeric;

org $26b5;
s_stk_dec:
	rst get_char;

org $26b6;
s_sd_skip:
	inc hl;
	ld a, (hl);
	cp ctrl_number;
	jr nz, s_sd_skip;
	inc hl;
	call stack_num;
	ld (ch_add), hl;

org $26c3;
s_numeric:
	set 6, (iy + _flags);
	jr s_cont_1;

org $26c9;
s_letter:
	call look_vars;
	jp c, report_2;
	call z, stk_var;
	ld a, (flags);
	cp %11000000;
	jr c, s_cont_1;
	inc hl;
	call stack_num;

org $26dd;
s_cont_1:
	jr s_cont_2;

org $26df;
s_negate:
	ld bc, $09db;
	cp '-';
	jr z, s_push_po;
	ld bc, $1018;
	cp tk_val_str;
	jr z, s_push_po;
	sub tk_code;
	jp c, report_c;
	ld bc, $04f0;
	cp 20;
	jr z, s_push_po;
	jp nc, report_c;
	ld b, 16;
	add a, 220;
	ld c, a;
	cp 223;
	jr nc, s_no_to_str;
	res 6, c;

org $2707;
s_no_to_str:
	cp 238;
	jr c, s_push_po;
	res 7, c;

org $270d;
s_push_po:
	push bc;
	rst next_char;
	jp s_loop_1;

org $2712;
s_cont_2:
	rst get_char;

org $2713;
s_cont_3:
	cp '(';
	jr nz, s_opertr;
	bit 6, (iy + _flags);
	jr nz, s_loop;
	call slicing;
	rst next_char;
	jr s_cont_3;

org $2723;
s_opertr:
	ld b, 0;
	ld c, a;
	ld hl, tbl_of_ops;
	call indexer;
	jr nc, s_loop;
	ld c, (hl);
	ld hl, tbl_priors - 195;
	add hl, bc;
	ld b, (hl);

org $2734;
s_loop:
	pop de;
	ld a, d;
	cp b;
	jr c, s_tighter;
	and a;
	jp z, _get_char;
	push bc;
	ld hl, flags;
	ld a, e;
	cp 237;
	jr nz, s_stk_lst;
	bit 6, (hl);
	jr nz, s_stk_lst;
	ld e, 153;

org $274c;
s_stk_lst:
	push de;
	call syntax_z;
	jr z, s_syntest;
	ld a, e;
	and %00111111;
	ld b, a;
	fwait();
	fsgl();
	fce();
	jr s_runtest;

org $275b;
s_syntest:
	ld a, e;
	xor (iy + _flags);
	and %01000000;

org $2761;
s_rport_c2:
	jp nz, report_c;

org $2764;
s_runtest:
	pop de;
	ld hl, flags;
	set 6, (hl);
	bit 7, e;
	jr nz, s_loopend;
	res 6, (hl);

org $2770;
s_loopend:
	pop bc;
	jr s_loop;

org $2773;
s_tighter:
	push de;
	ld a, c;
	bit 6, (iy + _flags);
	jr nz, s_next;
	and %00111111;
	add a, 8;
	ld c, a;
	cp $10 ; fbands;
	jr nz, s_not_and;
	set 6, c;
	jr s_next;

org $2788;
s_not_and:
	jr c, s_rport_c2;
	cp $17 ; fcat;
	jr z, s_next;
	set 7, c;

org $2790;
s_next:
	push bc;
	rst next_char;
	jp s_loop_1;

org $2795;
tbl_of_ops:
	defb '+', $cf;
	defb '-', $c3;
	defb '*', $c4;
	defb '/', $c5;
	defb '^', $c6;
	defb '=', $ce;
	defb '>', $cc;
	defb '<', $cd;
	defb tk_l_eql, $c9;
	defb tk_gr_eq, $ca;
	defb tk_neql, $cb;
	defb tk_or, $c7;
	defb tk_and, $c8;
	defb $00;

org $27b0;
tbl_priors:
	defb $06, $08, $08, $0a, $02, $03, $05, $05;
	defb $05, $05, $05, $05, $06;

org $27bd;
s_fn_sbrn:
	call syntax_z;
	jr nz, sf_run;
	rst next_char;
	call alpha;
	jp nc, report_c;
	rst next_char;
	cp '$';
	push af;
	jr nz, sf_brkt_1;
	rst next_char;

org $27d0;
sf_brkt_1:
	cp '(';
	jr nz, sf_rprt_c;
	rst next_char;
	cp ')';
	jr z, sf_flag_6;

org $27d9;
sf_argmts:
	call scanning;
	rst get_char;
	cp ',';
	jr nz, sf_brkt_2;
	rst next_char;
	jr sf_argmts;

org $27e4;
sf_brkt_2:
	cp ')';

org $27e6;
sf_rprt_c:
	jp nz, report_c;

org $27e9;
sf_flag_6:
	rst next_char;
	ld hl, flags;
	res 6, (hl);
	pop af;
	jr z, sf_syn_en;
	set 6, (hl);

org $27f4;
sf_syn_en:
	jp s_cont_2;

org $27f7;
sf_run:
	rst next_char;
	and %11011111;
	ld b, a;
	rst next_char;
	sub '$';
	ld c, a;
	jr nz, sf_argmt1;
	rst next_char;

org $2802;
sf_argmt1:
	rst next_char;
	push hl;
	ld hl, (prog);
	dec hl;

org $2808;
sf_fnd_df:
	ld de, $00ce;
	push bc;
	call look_prog;
	pop bc;
	jr nc, sf_cp_def;

org $2812;
report_p:
	rst error;
	defb fn_without_def;

org $2814;
sf_cp_def:
	push hl;
	call fn_skpovr;
	and %11011111;
	cp b;
	jr nz, sf_not_fd;
	call fn_skpovr;
	sub '$';
	cp c;
	jr z, sf_values;

org $2825;
sf_not_fd:
	pop hl;
	dec hl;
	ld de, $0200;
	push bc;
	call each_stmt;
	pop bc;
	jr sf_fnd_df;

org $2831;
sf_values:
	and a;
	call z, fn_skpovr;
	pop de;
	pop de;
	ld (ch_add), de;
	call fn_skpovr;
	push hl;
	cp ')';
	jr z, sf_r_br_2;

org $2843;
sf_arg_lp:
	inc hl;
	ld a, (hl);
	cp ctrl_number;
	ld d, 64;
	jr z, sf_arg_vl;
	dec hl;
	call fn_skpovr;
	inc hl;
	ld d, 0;

org $2852;
sf_arg_vl:
	inc hl;
	push hl;
	push de;
	call scanning;
	pop af;
	xor (iy + _flags);
	and %01000000;
	jr nz, report_q;
	pop hl;
	ex de, hl;
	ld hl, (stkend);
	ld bc, $0005;
	sbc hl, bc;
	ld (stkend), hl;
	ldir;
	ex de, hl;
	dec hl;
	call fn_skpovr;
	cp ')';
	jr z, sf_r_br_2;
	push hl;
	rst get_char;
	cp ',';
	jr nz, report_q;
	rst next_char;
	pop hl;
	call fn_skpovr;
	jr sf_arg_lp;

org $2885;
sf_r_br_2:
	push hl;
	rst get_char;
	cp ')';
	jr z, sf_value;

org $288b;
report_q:
	rst error;
	defb parameter_error;

org $288d;
sf_value:
	pop de;
	ex de, hl;
	ld (ch_add), hl;
	ld hl, (defadd);
	ex (sp), hl;
	ld (defadd), hl;
	push de;
	rst next_char;
	rst next_char;
	call scanning;
	pop hl;
	ld (ch_add), hl;
	pop hl;
	ld (defadd), hl;
	rst next_char;
	jp s_cont_2;

org $28ab;
fn_skpovr:
	inc hl;
	ld a, (hl);
	cp ' ' + 1;
	jr c, fn_skpovr;
	ret;

org $28b2;
look_vars:
	set 6, (iy + _flags);
	rst get_char;
	call alpha;
	jp nc, report_c;
	push hl;
	and %00011111;
	ld c, a;
	rst next_char;
	push hl;
	cp '(';
	jr z, v_run_syn;
	set 6, c;
	cp '$';
	jr z, v_str_var;
	set 5, c;
	call alphanum;
	jr nc, v_test_fn;

org $28d4;
v_char:
	call alphanum;
	jr nc, v_run_syn;
	res 6, c;
	rst next_char;
	jr v_char;

org $28de;
v_str_var:
	rst next_char;
	res 6, (iy + _flags);

org $28e3;
v_test_fn:
	ld a, (defadd_h);
	and a;
	jr z, v_run_syn;
	call syntax_z;
	jp nz, stk_f_arg;

org $28ef;
v_run_syn:
	ld b, c;
	call syntax_z;
	jr nz, v_run;
	ld a, c;
	and %11100000;
	set 7, a;
	ld c, a;
	jr v_syntax;

org $28fd;
v_run:
	ld hl, (vars);

org $2900;
v_each:
	ld a, (hl);
	and %01111111;
	jr z, v_80_byte;
	cp c;
	jr nz, v_next;
	rla;
	add a, a;
	jp p, v_found_2;
	jr c, v_found_2;
	pop de;
	push de;
	push hl;

org $2912;
v_matches:
	inc hl;

org $2913;
v_spaces:
	ld a, (de);
	inc de;
	cp ' ';
	jr z, v_spaces;
	or %00100000;
	cp (hl);
	jr z, v_matches;
	or %10000000;
	cp (hl);
	jr nz, v_get_ptr;
	ld a, (de);
	call alphanum;
	jr nc, v_found_1;

org $2929;
v_get_ptr:
	pop hl;

org $292a;
v_next:
	push bc;
	call next_one;
	ex de, hl;
	pop bc;
	jr v_each;

org $2932;
v_80_byte:
	set 7, b;

org $2934;
v_syntax:
	pop de;
	rst get_char;
	cp '(';
	jr z, v_pass;
	set 5, b;
	jr v_end;

org $293e;
v_found_1:
	pop de;

org $293f;
v_found_2:
	pop de;
	pop de;
	push hl;
	rst get_char;

org $2943;
v_pass:
	call alphanum;
	jr nc, v_end;
	rst next_char;
	jr v_pass;

org $294b;
v_end:
	pop hl;
	rl b;
	bit 6, b;
	ret;

org $2951;
stk_f_arg:
	ld hl, (defadd);
	ld a, (hl);
	cp ')';
	jp z, v_run_syn;

org $295a;
sfa_loop:
	ld a, (hl);
	or %01100000;
	ld b, a;
	inc hl;
	ld a, (hl);
	cp ctrl_number;
	jr z, sfa_cp_vr;
	dec hl;
	call fn_skpovr;
	inc hl;
	res 5, b;

org $296b;
sfa_cp_vr:
	ld a, b;
	cp c;
	jr z, sfa_match;
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	inc hl;
	call fn_skpovr;
	cp ')';
	jp z, v_run_syn;
	call fn_skpovr;
	jr sfa_loop;

org $2981;
sfa_match:
	bit 5, c;
	jr nz, sfa_end;
	inc hl;
	ld de, (stkend);
	call move_fp;
	ex de, hl;
	ld (stkend), hl;

org $2991;
sfa_end:
	pop de;
	pop de;
	xor a;
	inc a;
	ret;

org $2996;
stk_var:
	xor a;
	ld b, a;
	bit 7, c;
	jr nz, sv_count;
	bit 7, (hl);
	jr nz, sv_arrays;
	inc a;

org $29a1;
sv_simple_str:
	inc hl;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	inc hl;
	ex de, hl;
	call stk_sto_str;
	rst get_char;
	jp sv_slice_query;

org $29ae;
sv_arrays:
	inc hl;
	inc hl;
	inc hl;
	ld b, (hl);
	bit 6, c;
	jr z, sv_ptr;
	dec b;
	jr z, sv_simple_str;
	ex de, hl;
	rst get_char;
	cp '(';
	jr nz, report_3;
	ex de, hl;

org $29c0;
sv_ptr:
	ex de, hl;
	jr sv_count;

org $29c3;
sv_comma:
	push hl;
	rst get_char;
	pop hl;
	cp ',';
	jr z, sv_loop;
	bit 7, c;
	jr z, report_3;
	bit 6, c;
	jr nz, sv_close;
	cp ')';
	jr nz, sv_rpt_c;
	rst next_char;
	ret;

org $29d8;
sv_close:
	cp ')';
	jr z, sv_dim;
	cp tk_to;
	jr nz, sv_rpt_c;

org $29e0;
sv_ch_add:
	rst get_char;
	dec hl;
	ld (ch_add), hl;
	jr sv_slice;

org $29e7;
sv_count:
	ld hl, $0000;

org $29ea;
sv_loop:
	push hl;
	rst next_char;
	pop hl;
	ld a, c;
	cp %11000000;
	jr nz, sv_mult;
	rst get_char;
	cp ')';
	jr z, sv_dim;
	cp tk_to;
	jr z, sv_ch_add;

org $29fb;
sv_mult:
	push bc;
	push hl;
	call de_plus_1_to_de;
	ex (sp), hl;
	ex de, hl;
	call int_exp1;
	jr c, report_3;
	dec bc;
	call get_hl_x_de;
	add hl, bc;
	pop de;
	pop bc;
	djnz sv_comma;
	bit 7, c;

org $2a12;
sv_rpt_c:
	jr nz, sl_rpt_c;
	push hl;
	bit 6, c;
	jr nz, sv_elem_str;
	ld b, d;
	ld c, e;
	rst get_char;
	cp ')';
	jr z, sv_number;

org $2a20;
report_3:
	rst error;
	defb subscript_wrong;

org $2a22;
sv_number:
	rst next_char;
	pop hl;
	ld de, $0005;
	call get_hl_x_de;
	add hl, bc;
	ret;

org $2a2c;
sv_elem_str:
	call de_plus_1_to_de;
	ex (sp), hl;
	call get_hl_x_de;
	pop bc;
	add hl, bc;
	inc hl;
	ld b, d;
	ld c, e;
	ex de, hl;
	call stk_st_0;
	rst get_char;
	cp ')';
	jr z, sv_dim;
	cp ',';
	jr nz, report_3;

org $2a45;
sv_slice:
	call slicing;

org $2a48;
sv_dim:
	rst next_char;

org $2a49;
sv_slice_query:
	cp '(';
	jr z, sv_slice;
	res 6, (iy + _flags);
	ret;

org $2a52;
slicing:
	call syntax_z;
	call nz, stk_fetch;
	rst next_char;
	cp ')';
	jr z, sl_store;
	push de;
	xor a;
	push af;
	push bc;
	ld de, $0001;
	rst get_char;
	pop hl;
	cp tk_to;
	jr z, sl_second;
	pop af;
	call int_exp2;
	push af;
	ld d, b;
	ld e, c;
	push hl;
	rst get_char;
	pop hl;
	cp tk_to;
	jr z, sl_second;
	cp ')';

org $2a7a;
sl_rpt_c:
	jp nz, report_c;
	ld h, d;
	ld l, e;
	jr sl_define;

org $2a81;
sl_second:
	push hl;
	rst next_char;
	pop hl;
	cp ')';
	jr z, sl_define;
	pop af;
	call int_exp2;
	push af;
	rst get_char;
	ld h, b;
	ld l, c;
	cp ')';
	jr nz, sl_rpt_c;

org $2a94;
sl_define:
	pop af;
	ex (sp), hl;
	add hl, de;
	dec hl;
	ex (sp), hl;
	and a;
	sbc hl, de;
	ld bc, $0000;
	jr c, sl_over;
	inc hl;
	and a;
	jp m, report_3;
	ld b, h;
	ld c, l;

org $2aa8;
sl_over:
	pop de;
	res 6, (iy + _flags);

org $2aad;
sl_store:
	call syntax_z;
	ret z;

org $2ab1;
stk_st_0:
	xor a;

org $2ab2;
stk_sto_str:
	res 6, (iy + _flags);

org $2ab6;
stk_store:
	push bc;
	call test_5_sp;
	pop bc;
	ld hl, (stkend);
	ld (hl), a;
	inc hl;
	ld (hl), e;
	inc hl;
	ld (hl), d;
	inc hl;
	ld (hl), c;
	inc hl;
	ld (hl), b;
	inc hl;
	ld (stkend), hl;
	ret;

org $2acc;
int_exp1:
	xor a;

org $2acd;
int_exp2:
	push de;
	push hl;
	push af;
	call expt_1num;
	pop af;
	call syntax_z;
	jr z, i_restore;
	push af;
	call find_int2;
	pop de;
	ld a, b;
	or c;
	scf;
	jr z, i_carry;
	pop hl;
	push hl;
	and a;
	sbc hl, bc;

org $2ae8;
i_carry:
	ld a, d;
	sbc a, 0;

org $2aeb;
i_restore:
	pop hl;
	pop de;
	ret;

org $2aee;
de_plus_1_to_de:
	ex de, hl;
	inc hl;
	ld e, (hl);
	inc hl;
	ld d, (hl);
	ret;

org $2af4;
get_hl_x_de:
	call syntax_z;
	ret z;
	call hl_hl_x_de;
	jp c, report_4;
	ret;

org $2aff;
let:
	ld hl, (dest);
	bit 1, (iy + _flagx);
	jr z, l_exists;
	ld bc, $0005;

org $2b0b;
l_each_ch:
	inc bc;

org $2b0c;
l_no_sp:
	inc hl;
	ld a, (hl);
	cp ' ';
	jr z, l_no_sp;
	jr nc, l_test_ch;
	cp 16;
	jr c, l_spaces;
	cp 22;
	jr nc, l_spaces;
	inc hl;
	jr l_no_sp;

org $2b1f;
l_test_ch:
	call alphanum;
	jr c, l_each_ch;
	cp '$';
	jp z, l_new_str;

org $2b29;
l_spaces:
	ld a, c;
	ld hl, (e_line);
	dec hl;
	call make_room;
	inc hl;
	inc hl;
	ex de, hl;
	push de;
	ld hl, (dest);
	dec de;
	sub 6;
	ld b, a;
	jr z, l_single;

org $2b3e;
l_char:
	inc hl;
	ld a, (hl);
	cp ' ' + 1;
	jr c, l_char;
	or %00100000;
	inc de;
	ld (de), a;
	djnz l_char;
	or %10000000;
	ld (de), a;
	ld a, %11000000;

org $2b4f;
l_single:
	ld hl, (dest);
	xor (hl);
	or %00100000;
	pop hl;
	call l_first;

org $2b59;
l_numeric:
	push hl;
	fwait();
	fdel();
	fce();
	pop hl;
	ld bc, $0005;
	and a;
	sbc hl, bc;
	jr l_enter;

org $2b66;
l_exists:
	bit 6, (iy + _flags);
	jr z, l_delete_str;
	ld de, $0006;
	add hl, de;
	jr l_numeric;

org $2b72;
l_delete_str:
	ld hl, (dest);
	ld bc, (strlen);
	bit 0, (iy + _flagx);
	jr nz, l_add_str;
	ld a, b;
	or c;
	ret z;
	push hl;
	rst bc_spaces;
	push de;
	push bc;
	ld d, h;
	ld e, l;
	inc hl;
	ld (hl), ' ';
	lddr;
	push hl;
	call stk_fetch;
	pop hl;
	ex (sp), hl;
	and a;
	sbc hl, bc;
	add hl, bc;
	jr nc, l_length;
	ld b, h;
	ld c, l;

org $2b9b;
l_length:
	ex (sp), hl;
	ex de, hl;
	ld a, b;
	or c;
	jr z, l_in_w_s;
	ldir;

org $2ba3;
l_in_w_s:
	pop bc;
	pop de;
	pop hl;

org $2ba6;
l_enter:
	ex de, hl;
	ld a, b;
	or c;
	ret z;
	push de;
	ldir;
	pop hl;
	ret;

org $2baf;
l_add_str:
	dec hl;
	dec hl;
	dec hl;
	ld a, (hl);
	push hl;
	push bc;
	call l_string;
	pop bc;
	pop hl;
	inc bc;
	inc bc;
	inc bc;
	jp reclaim_2;

org $2bc0;
l_new_str:
	ld a, %11011111;
	ld hl, (dest);
	and (hl);

org $2bc6;
l_string:
	push af;
	call stk_fetch;
	ex de, hl;
	add hl, bc;
	push bc;
	dec hl;
	ld (dest), hl;
	inc bc;
	inc bc;
	inc bc;
	ld hl, (e_line);
	dec hl;
	call make_room;
	ld hl, (dest);
	pop bc;
	push bc;
	inc bc;
	lddr;
	ex de, hl;
	inc hl;
	pop bc;
	ld (hl), b;
	dec hl;
	ld (hl), c;
	pop af;

org $2bea;
l_first:
	dec hl;
	ld (hl), a;
	ld hl, (e_line);
	dec hl;
	ret;

org $2bf1;
stk_fetch:
	ld hl, (stkend);
	dec hl;
	ld b, (hl);
	dec hl;
	ld c, (hl);
	dec hl;
	ld d, (hl);
	dec hl;
	ld e, (hl);
	dec hl;
	ld a, (hl);
	ld (stkend), hl;
	ret;

org $2c02;
dim:
	call look_vars;

org $2c05;
d_rport_c:
	jp nz, report_c;
	call syntax_z;
	jr nz, d_run;
	res 6, c;
	call stk_var;
	call check_end;

org $2c15;
d_run:
	jr c, d_letter;
	push bc;
	call next_one;
	call reclaim_2;
	pop bc;

org $2c1f;
d_letter:
	set 7, c;
	ld b, 0;
	push bc;
	ld hl, $0001;
	bit 6, c;
	jr nz, d_size;
	ld l, 5;

org $2c2d;
d_size:
	ex de, hl;

org $2c2e;
d_no_loop:
	rst next_char;
	ld h, 255;
	call int_exp1;
	jp c, report_3;
	pop hl;
	push bc;
	inc h;
	push hl;
	ld h, b;
	ld l, c;
	call get_hl_x_de;
	ex de, hl;
	rst get_char;
	cp ',';
	jr z, d_no_loop;
	cp ')';
	jr nz, d_rport_c;
	rst next_char;
	pop bc;
	ld a, c;
	ld l, b;
	ld h, 0;
	inc hl;
	inc hl;
	add hl, hl;
	add hl, de;
	jp c, report_4;
	push de;
	push bc;
	push hl;
	ld b, h;
	ld c, l;
	ld hl, (e_line);
	dec hl;
	call make_room;
	inc hl;
	ld (hl), a;
	pop bc;
	dec bc;
	dec bc;
	dec bc;
	inc hl;
	ld (hl), c;
	inc hl;
	ld (hl), b;
	pop bc;
	ld a, b;
	inc hl;
	ld (hl), a;
	ld h, d;
	ld l, e;
	dec de;
	ld (hl), 0;
	bit 6, c;
	jr z, dim_clear;
	ld (hl), ' ';

org $2c7c;
dim_clear:
	pop bc;
	lddr;

org $2c7f;
dim_sizes:
	pop bc;
	ld (hl), b;
	dec hl;
	ld (hl), c;
	dec hl;
	dec a;
	jr nz, dim_sizes;
	ret;

org $2c88;
alphanum:
	call numeric;
	ccf;
	ret c;

org $2c8d;
alpha:
	cp 'A';
	ccf;
	ret nc;
	cp 'Z' + 1;
	ret c;
	cp 'a';
	ccf;
	ret nc;
	cp 'z' + 1;
	ret;

org $2c9b;
dec_to_fp:
	cp tk_bin;
	jr nz, not_bin;
	ld de, $0000;

org $2ca2;
bin_digit:
	rst next_char;
	sub '1';
	adc a, 0;
	jr nz, bin_end;
	ex de, hl;
	ccf;
	adc hl, hl;
	jp c, report_6;
	ex de, hl;
	jr bin_digit;

org $2cb3;
bin_end:
	ld b, d;
	ld c, e;
	jp stack_bc;

org $2cb8;
not_bin:
	cp '.';
	jr z, decimal;
	call int_to_fp;
	cp '.';
	jr nz, e_format;
	rst next_char;
	call numeric;
	jr c, e_format;
	jr dec_sto_1;

org $2ccb;
decimal:
	rst next_char;
	call numeric;

org $2ccf;
dec_rpt_c:
	jp c, report_c;
	fwait();
	fstk0();
	fce();

org $2cd5;
dec_sto_1:
	fwait();
	fstk1();
	fst(0);
	fdel();
	fce();

org $2cda;
nxt_dgt_1:
	rst get_char;
	call stk_digit;
	jr c, e_format;
	fwait();
	fgt(0);
	fstk10();
	fdiv();
	fst(0);
	fmul();
	fadd();
	fce();
	rst next_char;
	jr nxt_dgt_1;

org $2ceb;
e_format:
	cp 'E';
	jr z, sign_flag;
	cp 'e';
	ret nz;

org $2cf2;
sign_flag:
	ld b, 255;
	rst next_char;
	cp '+';
	jr z, sign_done;
	cp '-';
	jr nz, st_e_part;
	inc b;

org $2cfe;
sign_done:
	rst next_char;

org $2cff;
st_e_part:
	call numeric;
	jr c, dec_rpt_c;
	push bc;
	call int_to_fp;
	call fp_to_a;
	pop bc;
	jp c, report_6;
	and a;
	jp m, report_6;
	inc b;
	jr z, e_fp_jump;
	neg;

org $2d18;
e_fp_jump:
	jp fp_e_to_fp;

org $2d1b;
numeric:
	cp '0';
	ret c;
	cp '9' + 1;
	ccf;
	ret;

org $2d22;
stk_digit:
	call numeric;
	ret c;
	sub '0';

org $2d28;
stack_a:
	ld c, a;
	ld b, 0;

org $2d2b;
stack_bc:
	ld iy, err_nr;
	xor a;
	ld e, a;
	ld d, c;
	ld c, b;
	ld b, a;
	call stk_store;
	fwait();
	fce();
	and a;
	ret;

org $2d3b;
int_to_fp:
	push af;
	fwait();
	fstk0();
	fce();
	pop af;

org $2d40;
nxt_dgt_2:
	call stk_digit;
	ret c;
	fwait();
	fxch();
	fstk10();
	fmul();
	fadd();
	fce();
	call ch_add_plus_1;
	jr nxt_dgt_2;

org $2d4f;
fp_e_to_fp:
	rlca;
	rrca;
	jr nc, e_save;
	cpl;
	inc a;

org $2d55;
e_save:
	push af;
	ld hl, membot;
	call fp_0_div_1;
	fwait();
	fstk10();
	fce();
	pop af;

org $2d60;
e_loop:
	srl a;
	jr nc, e_tst_end;
	push af;
	fwait();
	fst(1);
	fgt(0);
	fjpt(e_divsn);
	fmul();
	fjp(e_fetch);

org $2d6d;
e_divsn:
	fdiv();

org $2d6e;
e_fetch:
	fgt(1);
	fce();
	pop af;

org $2d71;
e_tst_end:
	jr z, e_end;
	push af;
	fwait();
	fmove();
	fmul();
	fce();
	pop af;
	jr e_loop;

org $2d7b;
e_end:
	fwait();
	fdel();
	fce();
	ret;

org $2d7f;
int_fetch:
	inc hl;
	ld c, (hl);
	inc hl;
	ld a, (hl);
	xor c;
	sub c;
	ld e, a;
	inc hl;
	ld a, (hl);
	adc a, c;
	xor c;
	ld d, a;
	ret;

org $2d8c;
p_int_sto:
	ld c, 0;

org $2d8e;
int_store:
	push hl;
	ld (hl), 0;
	inc hl;
	ld (hl), c;
	inc hl;
	ld a, e;
	xor c;
	sub c;
	ld (hl), a;
	inc hl;
	ld a, d;
	adc a, c;
	xor c;
	ld (hl), a;
	inc hl;
	ld (hl), 0;
	pop hl;
	ret;

org $2da2;
fp_to_bc:
	fwait();
	fce();
	ld a, (hl);
	and a;
	jr z, fp_to_bc_delete;
	fwait();
	fstkhalf();
	fadd();
	fint();
	fce();

org $2dad;
fp_to_bc_delete:
	fwait();
	fdel();
	fce();
	push hl;
	push de;
	ex de, hl;
	ld b, (hl);
	call int_fetch;
	xor a;
	sub b;
	bit 7, c;
	ld b, d;
	ld c, e;
	ld a, e;
	pop de;
	pop hl;
	ret;

org $2dc1;
log_2_a:
	ld d, a;
	rla;
	sbc a, a;
	ld e, a;
	ld c, a;
	xor a;
	ld b, a;
	call stk_store;
	fwait();
	fstk();
	defb $ef, $1a, $20, $9a, $85;
	fmul();
	fint();
	fce();

org $2dd5;
fp_to_a:
	call fp_to_bc;
	ret c;
	push af;
	dec b;
	inc b;
	jr z, fp_a_end;
	pop af;
	scf;
	ret;

org $2de1;
fp_a_end:
	pop af;
	ret;

org $2de3;
print_fp:
	fwait();
	fmove();
	fcp(_lz);
	fjpt(pf_negtve);
	fmove();
	fcp(_gz);
	fjpt(pf_postve);
	fdel();
	fce();
	ld a, '0';
	rst print_a;
	ret;

org $2df2;
pf_negtve:
	fabs();
	fce();
	ld a, '-';
	rst print_a;
	fwait();

org $2df8;
pf_postve:
	fstk0();
	fst(3);
	fst(4);
	fst(5);
	fdel();
	fce();
	exx;
	push hl;
	exx;

org $2e01;
pf_loop:
	fwait();
	fmove();
	fint();
	fst(2);
	fsub();
	fgt(2);
	fxch();
	fst(2);
	fdel();
	fce();
	ld a, (hl);
	and a;
	jr nz, pf_large;
	call int_fetch;
	ld b, 16;
	ld a, d;
	and a;
	jr nz, pf_save;
	or e;
	jr z, pf_small;
	ld d, e;
	ld b, 8;

org $2e1e;
pf_save:
	push de;
	exx;
	pop de;
	exx;
	jr pf_bits;

org $2e24;
pf_small:
	fwait();
	fgt(2);
	fce();
	ld a, (hl);
	sub 126;
	call log_2_a;
	ld d, a;
	ld a, (mem_5_1);
	sub d;
	ld (mem_5_1), a;
	ld a, d;
	call fp_e_to_fp;
	fwait();
	fmove();
	fint();
	fst(1);
	fsub();
	fgt(1);
	fce();
	call fp_to_a;
	push hl;
	ld (mem_3), a;
	dec a;
	rla;
	sbc a, a;
	inc a;
	ld hl, mem_5;
	ld (hl), a;
	inc hl;
	add a, (hl);
	ld (hl), a;
	pop hl;
	jp pf_fractn;

org $2e56;
pf_large:
	sub 128;
	cp 28;
	jr c, pf_medium;
	call log_2_a;
	sub 7;
	ld b, a;
	ld hl, mem_5_1;
	add a, (hl);
	ld (hl), a;
	ld a, b;
	neg;
	call fp_e_to_fp;
	jr pf_loop;

org $2e6f;
pf_medium:
	ex de, hl;
	call fetch_two;
	exx;
	set 7, d;
	ld a, l;
	exx;
	sub 128;
	ld b, a;

org $2e7b;
pf_bits:
	sla e;
	rl d;
	exx;
	rl e;
	rl d;
	exx;
	ld hl, mem_4_4;
	ld c, 5;

org $2e8a;
pf_bytes:
	ld a, (hl);
	adc a, a;
	daa;
	ld (hl), a;
	dec hl;
	dec c;
	jr nz, pf_bytes;
	djnz pf_bits;
	xor a;
	ld hl, mem_4;
	ld de, mem_3;
	ld b, $09;
	rld;
	ld c, 255;

org $2ea1;
pf_digits:
	rld;
	jr nz, pf_insert;
	dec c;
	inc c;
	jr nz, pf_test_2;

org $2ea9;
pf_insert:
	ld (de), a;
	inc de;
	inc (iy + _mem_5);
	inc (iy + _mem_5_1);
	ld c, 0;

org $2eb3;
pf_test_2:
	bit 0, b;
	jr z, pf_all_9;
	inc hl;

org $2eb8;
pf_all_9:
	djnz pf_digits;
	ld a, (mem_5);
	sub 9;
	jr c, pf_more;
	dec (iy + _mem_5);
	ld a, 4;
	cp (iy + _mem_4_3);
	jr pf_round;

org $2ecb;
pf_more:
	fwait();
	fdel();
	fgt(2);
	fce();

org $2ecf;
pf_fractn:
	ex de, hl;
	call fetch_two;
	exx;
	ld a, 128;
	sub l;
	ld l, 0;
	set 7, d;
	exx;
	call shift_fp;

org $2edf;
pf_frn_lp:
	ld a, (iy + _mem_5);
	cp 8;
	jr c, pf_fr_dgt;
	exx;
	rl d;
	exx;
	jr pf_round;

org $2eec;
pf_fr_dgt:
	ld bc, $0200;

org $2eef;
pf_fr_exx:
	ld a, e;
	call ca_10a_plus_c;
	ld e, a;
	ld a, d;
	call ca_10a_plus_c;
	ld d, a;
	push bc;
	exx;
	pop bc;
	djnz pf_fr_exx;
	ld hl, mem_3;
	ld a, c;
	ld c, (iy + _mem_5);
	add hl, bc;
	ld (hl), a;
	inc (iy + _mem_5);
	jr pf_frn_lp;

org $2f0c;
pf_round:
	push af;
	ld hl, mem_3;
	ld c, (iy + _mem_5);
	ld b, 0;
	add hl, bc;
	ld b, c;
	pop af;

org $2f18;
pf_rnd_lp:
	dec hl;
	ld a, (hl);
	adc a, 0;
	ld (hl), a;
	and a;
	jr z, pf_r_back;
	cp 10;
	ccf;
	jr nc, pf_count;

org $2f25;
pf_r_back:
	djnz pf_rnd_lp;
	ld (hl), 1;
	inc b;
	inc (iy + _mem_5_1);

org $2f2d;
pf_count:
	ld (iy + _mem_5), b;
	fwait();
	fdel();
	fce();
	exx;
	pop hl;
	exx;
	ld bc, (mem_5);
	ld hl, mem_3;
	ld a, b;
	cp 9;
	jr c, pf_not_e;
	cp 252;
	jr c, pf_e_frmt;

org $2f46;
pf_not_e:
	and a;
	call z, out_code;

org $2f4a;
pf_e_sbrn:
	xor a;
	sub b;
	jp m, pf_out_lp;
	ld b, a;
	jr pf_dc_out;

org $2f52;
pf_out_lp:
	ld a, c;
	and a;
	jr z, pf_out_dt;
	ld a, (hl);
	inc hl;
	dec c;

org $2f59;
pf_out_dt:
	call out_code;
	djnz pf_out_lp;

org $2f5e;
pf_dc_out:
	ld a, c;
	and a;
	ret z;
	inc b;
	ld a, '.';

org $2f64;
pf_dec_0s:
	rst print_a;
	ld a, '0';
	djnz pf_dec_0s;
	ld b, c;
	jr pf_out_lp;

org $2f6c;
pf_e_frmt:
	ld d, b;
	dec d;
	ld b, 1;
	call pf_e_sbrn;
	ld a, 'E';
	rst print_a;
	ld c, d;
	ld a, c;
	and a;
	jp p, pf_e_pos;
	neg;
	ld c, a;
	ld a, '-';
	jr pf_e_sign;

org $2f83;
pf_e_pos:
	ld a, '+';

org $2f85;
pf_e_sign:
	rst print_a;
	ld b, 0;
	jp out_num_1;

org $2f8b;
ca_10a_plus_c:
	push de;
	ld l, a;
	ld h, 0;
	ld e, l;
	ld d, h;
	add hl, hl;
	add hl, hl;
	add hl, de;
	add hl, hl;
	ld e, c;
	add hl, de;
	ld c, h;
	ld a, l;
	pop de;
	ret;

org $2f9b;
prep_add:
	ld a, (hl);
	ld (hl), 0;
	and a;
	ret z;
	inc hl;
	bit 7, (hl);
	set 7, (hl);
	dec hl;
	ret z;
	push bc;
	ld bc, $0005;
	add hl, bc;
	ld b, c;
	ld c, a;
	scf;

org $2faf;
neg_byte:
	dec hl;
	ld a, (hl);
	cpl;
	adc a, 0;
	ld (hl), a;
	djnz neg_byte;
	ld a, c;
	pop bc;
	ret;

org $2fba;
fetch_two:
	push hl;
	push af;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	ld (hl), a;
	inc hl;
	ld a, c;
	ld c, (hl);
	push bc;
	inc hl;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	ex de, hl;
	ld d, a;
	ld e, (hl);
	push de;
	inc hl;
	ld d, (hl);
	inc hl;
	ld e, (hl);
	push de;
	exx;
	pop de;
	pop hl;
	pop bc;
	exx;
	inc hl;
	ld d, (hl);
	inc hl;
	ld e, (hl);
	pop af;
	pop hl;
	ret;

org $2fdd;
shift_fp:
	and a;
	ret z;
	cp 33;
	jr nc, addend_0;
	push bc;
	ld b, a;

org $2fe5;
one_shift:
	exx;
	sra l;
	rr d;
	rr e;
	exx;
	rr d;
	rr e;
	djnz one_shift;
	pop bc;
	ret nc;
	call add_back;
	ret nz;

org $2ff9;
addend_0:
	exx;
	xor a;

org $2ffb;
zeros_4_5:
	ld l, 0;
	ld d, a;
	ld e, l;
	exx;
	ld de, $0000;
	ret;

org $3004;
add_back:
	inc e;
	ret nz;
	inc d;
	ret nz;
	exx;
	inc e;
	jr nz, all_added;
	inc d;

org $300d;
all_added:
	exx;
	ret;

org $300f;
fp_subtract:
	ex de, hl;
	call fp_negate;
	ex de, hl;

org $3014;
fp_addition:
	ld a, (de);
	or (hl);
	jr nz, full_addn;
	push de;
	inc hl;
	push hl;
	inc hl;
	ld e, (hl);
	inc hl;
	ld d, (hl);
	inc hl;
	inc hl;
	inc hl;
	ld a, (hl);
	inc hl;
	ld c, (hl);
	inc hl;
	ld b, (hl);
	pop hl;
	ex de, hl;
	add hl, bc;
	ex de, hl;
	adc a, (hl);
	rrca;
	adc a, 0;
	jr nz, addn_oflw;
	sbc a, a;
	ld (hl), a;
	inc hl;
	ld (hl), e;
	inc hl;
	ld (hl), d;
	dec hl;
	dec hl;
	dec hl;
	pop de;
	ret;

org $303c;
addn_oflw:
	dec hl;
	pop de;

org $303e;
full_addn:
	call re_st_two;
	exx;
	push hl;
	exx;
	push de;
	push hl;
	call prep_add;
	ld b, a;
	ex de, hl;
	call prep_add;
	ld c, a;
	cp b;
	jr nc, shift_len;
	ld a, b;
	ld b, c;
	ex de, hl;

org $3055;
shift_len:
	push af;
	sub b;
	call fetch_two;
	call shift_fp;
	pop af;
	pop hl;
	ld (hl), a;
	push hl;
	ld l, b;
	ld h, c;
	add hl, de;
	exx;
	ex de, hl;
	adc hl, bc;
	ex de, hl;
	ld a, h;
	adc a, l;
	ld l, a;
	rra;
	xor l;
	exx;
	ex de, hl;
	pop hl;
	rra;
	jr nc, test_neg;
	ld a, 1;
	call shift_fp;
	inc (hl);
	jr z, add_rep_6;

org $307c;
test_neg:
	exx;
	ld a, l;
	and %10000000;
	exx;
	inc hl;
	ld (hl), a;
	dec hl;
	jr z, go_nc_mlt;
	ld a, e;
	neg;
	ccf;
	ld e, a;
	ld a, d;
	cpl;
	adc a, 0;
	ld d, a;
	exx;
	ld a, e;
	cpl;
	adc a, 0;
	ld e, a;
	ld a, d;
	cpl;
	adc a, 0;
	jr nc, end_compl;
	rra;
	exx;
	inc (hl);

org $309f;
add_rep_6:
	jp z, report_6;
	exx;

org $30a3;
end_compl:
	ld d, a;
	exx;

org $30a5;
go_nc_mlt:
	xor a;
	jp test_norm;

org $30a9;
hl_hl_x_de:
	push bc;
	ld b, 16;
	ld a, h;
	ld c, l;
	ld hl, $0000;

org $30b1;
hl_loop:
	add hl, hl;
	jr c, hl_end;
	rl c;
	rla;
	jr nc, hl_again;
	add hl, de;
	jr c, hl_end;

org $30bc;
hl_again:
	djnz hl_loop;

org $30be;
hl_end:
	pop bc;
	ret;

org $30c0;
prep_m_d:
	call test_zero;
	ret c;
	inc hl;
	xor (hl);
	set 7, (hl);
	dec hl;
	ret;

org $30ca;
fp_multiply:
	ld a, (de);
	or (hl);
	jr nz, mult_long;
	push de;
	push hl;
	push de;
	call int_fetch;
	ex de, hl;
	ex (sp), hl;
	ld b, c;
	call int_fetch;
	ld a, b;
	xor c;
	ld c, a;
	pop hl;
	call hl_hl_x_de;
	ex de, hl;
	pop hl;
	jr c, mult_oflw;
	ld a, d;
	or e;
	jr nz, mult_rslt;
	ld c, a;

org $30ea;
mult_rslt:
	call int_store;
	pop de;
	ret;

org $30ef;
mult_oflw:
	pop de;

org $30f0;
mult_long:
	call re_st_two;
	xor a;
	call prep_m_d;
	ret c;
	exx;
	push hl;
	exx;
	push de;
	ex de, hl;
	call prep_m_d;
	ex de, hl;
	jr c, zero_rslt;
	push hl;
	call fetch_two;
	ld a, b;
	and a;
	sbc hl, hl;
	exx;
	push hl;
	sbc hl, hl;
	exx;
	ld b, 33;
	jr strt_mlt;

org $3114;
mlt_loop:
	jr nc, no_add;
	add hl, de;
	exx;
	adc hl, de;
	exx;

org $311b;
no_add:
	exx;
	rr h;
	rr l;
	exx;
	rr h;
	rr l;

org $3125;
strt_mlt:
	exx;
	rr b;
	rr c;
	exx;
	rr c;
	rra;
	djnz mlt_loop;
	ex de, hl;
	exx;
	ex de, hl;
	exx;
	pop bc;
	pop hl;
	ld a, b;
	add a, c;
	jr nz, make_expt;
	and a;

org $313b;
make_expt:
	dec a;
	ccf;

org $313d;
divn_expt:
	rla;
	ccf;
	rra;
	jp p, oflw1_clr;
	jr nc, report_6;
	and a;

org $3146;
oflw1_clr:
	inc a;
	jr nz, oflw2_clr;
	jr c, oflw2_clr;
	exx;
	bit 7, d;
	exx;
	jr nz, report_6;

org $3151;
oflw2_clr:
	ld (hl), a;
	exx;
	ld a, b;
	exx;

org $3155;
test_norm:
	jr nc, normalise;
	ld a, (hl);
	and a;

org $3159;
near_zero:
	ld a, 128;
	jr z, skip_zero;

org $315d;
zero_rslt:
	xor a;

org $315e;
skip_zero:
	exx;
	and d;
	call zeros_4_5;
	rlca;
	ld (hl), a;
	jr c, oflow_clr;
	inc hl;
	ld (hl), a;
	dec hl;
	jr oflow_clr;

org $316c;
normalise:
	ld b, 32;

org $316e;
shift_one:
	exx;
	bit 7, d;
	exx;
	jr nz, norml_now;
	rlca;
	rl e;
	rl d;
	exx;
	rl e;
	rl d;
	exx;
	dec (hl);
	jr z, near_zero;
	djnz shift_one;
	jr zero_rslt;

org $3186;
norml_now:
	rla;
	jr nc, oflow_clr;
	call add_back;
	jr nz, oflow_clr;
	exx;
	ld d, 128;
	exx;
	inc (hl);
	jr z, report_6;

org $3195;
oflow_clr:
	push hl;
	inc hl;
	exx;
	push de;
	exx;
	pop bc;
	ld a, b;
	rla;
	rl (hl);
	rra;
	ld (hl), a;
	inc hl;
	ld (hl), c;
	inc hl;
	ld (hl), d;
	inc hl;
	ld (hl), e;
	pop hl;
	pop de;
	exx;
	pop hl;
	exx;
	ret;

org $31ad;
report_6:
	rst error;
	defb number_too_big;

org $31af;
fp_division:
	call re_st_two;
	ex de, hl;
	xor a;
	call prep_m_d;
	jr c, report_6;
	ex de, hl;
	call prep_m_d;
	ret c;
	exx;
	push hl;
	exx;
	push de;
	push hl;
	call fetch_two;
	exx;
	push hl;
	ld h, b;
	ld l, c;
	exx;
	ld h, c;
	ld l, b;
	xor a;
	ld b, $df;
	jr div_start;

org $31d2;
div_loop:
	rla;
	rl c;
	exx;
	rl c;
	rl b;
	exx;

org $31db;
div_34th:
	add hl, hl;
	exx;
	adc hl, hl;
	exx;
	jr c, subn_only;

org $31e2;
div_start:
	sbc hl, de;
	exx;
	sbc hl, de;
	exx;
	jr nc, no_rstore;
	add hl, de;
	exx;
	adc hl, de;
	exx;
	and a;
	jr count_one;

org $31f2;
subn_only:
	and a;
	sbc hl, de;
	exx;
	sbc hl, de;
	exx;

org $31f9;
no_rstore:
	scf;

org $31fa;
count_one:
	inc b;
	jp m, div_loop;
	push af;
	jr z, div_start;
	ld e, a;
	ld d, c;
	exx;
	ld e, c;
	ld d, b;
	pop af;
	rr b;
	pop af;
	rr b;
	exx;
	pop bc;
	pop hl;
	ld a, b;
	sub c;
	jp divn_expt;

org $3214;
fp_truncate:
	ld a, (hl);
	and a;
	ret z;
	cp 129;
	jr nc, t_gr_zero;
	ld (hl), 0;
	ld a, 32;
	jr nil_bytes;

org $3221;
t_gr_zero:
	cp 145;
	jr nz, t_small;
	inc hl;
	inc hl;
	inc hl;
	ld a, 128;
	and (hl);
	dec hl;
	or (hl);
	dec hl;
	jr nz, t_first;
	ld a, 128;
	xor (hl);

org $3233;
t_first:
	dec hl;
	jr nz, t_expnent;
	ld (hl), a;
	inc hl;
	ld (hl), 255;
	dec hl;
	ld a, 24;
	jr nil_bytes;

org $323f;
t_small:
	jr nc, x_large;
	push de;
	cpl;
	add a, 145;
	inc hl;
	ld d, (hl);
	inc hl;
	ld e, (hl);
	dec hl;
	dec hl;
	ld c, 0;
	bit 7, d;
	jr z, t_numeric;
	dec c;

org $3252;
t_numeric:
	set 7, d;
	ld b, 8;
	sub b;
	add a, b;
	jr c, t_test;
	ld e, d;
	ld d, 0;
	sub b;

org $325e;
t_test:
	jr z, t_store;
	ld b, a;

org $3261;
t_shift:
	srl d;
	rr e;
	djnz t_shift;

org $3267;
t_store:
	call int_store;
	pop de;
	ret;

org $326c;
t_expnent:
	ld a, (hl);

org $326d;
x_large:
	sub 160;
	ret p;
	neg;

org $3272;
nil_bytes:
	push de;
	ex de, hl;
	dec hl;
	ld b, a;
	srl b;
	srl b;
	srl b;
	jr z, bits_zero;

org $327e;
byte_zero:
	ld (hl), 0;
	dec hl;
	djnz byte_zero;

org $3283;
bits_zero:
	and %00000111;
	jr z, ix_end;
	ld b, a;
	ld a, 255;

org $328a;
less_mask:
	sla a;
	djnz less_mask;
	and (hl);
	ld (hl), a;

org $3290;
ix_end:
	ex de, hl;
	pop de;
	ret;

org $3293;
re_st_two:
	call restk_sub;

org $3296;
restk_sub:
	ex de, hl;

org $3297;
fp_re_stack:
	ld a, (hl);
	and a;
	ret nz;
	push de;
	call int_fetch;
	xor a;
	inc hl;
	ld (hl), a;
	dec hl;
	ld (hl), a;
	ld b, 145;
	ld a, d;
	and a;
	jr nz, rs_nrmlse;
	or e;
	ld b, d;
	jr z, rs_store;
	ld d, e;
	ld e, b;
	ld b, 137;

org $32b1;
rs_nrmlse:
	ex de, hl;

org $32b2;
rstk_loop:
	dec b;
	add hl, hl;
	jr nc, rstk_loop;
	rrc c;
	rr h;
	rr l;
	ex de, hl;

org $32bd;
rs_store:
	dec hl;
	ld (hl), e;
	dec hl;
	ld (hl), d;
	dec hl;
	ld (hl), b;
	pop de;
	ret;

org $32c5;
cn_stk_zero:
	defb $00, $b0, $00;

org $32c8;
cn_stk_one:
	defb $40, $b0, $00, $01;

org $32cc;
cn_stk_half:
	defb $30, $00;

org $32ce;
cn_stk_pi_div_2:
	defb $f1, $49, $0f, $da, $a2;

org $32d3;
cn_stk_ten:
	defb $40, $b0, $00, $0a;

org $32d7;
tbl_addrs:
	defw fp_jump_true;
	defw fp_exchange;
	defw fp_delete;
	defw fp_subtract;
	defw fp_multiply;
	defw fp_division;
	defw fp_to_power;
	defw fp_or;
	defw fp_no_and_no;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_addition;
	defw fp_str_and_no;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_comparison;
	defw fp_strs_add;
	defw fp_val_str;
	defw fp_usr_str;
	defw fp_read_in;
	defw fp_negate;
	defw fp_code;
	defw fp_val;
	defw fp_len;
	defw fp_sin;
	defw fp_cos;
	defw fp_tan;
	defw fp_asn;
	defw fp_acs;
	defw fp_atn;
	defw fp_ln;
	defw fp_exp;
	defw fp_int;
	defw fp_sqr;
	defw fp_sgn;
	defw fp_abs;
	defw fp_peek;
	defw fp_in;
	defw fp_usr_no;
	defw fp_str_str;
	defw fp_chr_str;
	defw fp_not;
	defw fp_duplicate;
	defw fp_n_mod_m;
	defw fp_jump;
	defw fp_stk_data;
	defw fp_dec_jr_nz;
	defw fp_less_0;
	defw fp_greater_0;
	defw fp_end_calc;
	defw fp_get_argt;
	defw fp_truncate;
	defw fp_calc_2;
	defw fp_e_to_fp;
	defw fp_re_stack;
	defw fp_series_xx;
	defw fp_stk_const_xx;
	defw fp_st_mem_xx;
	defw fp_get_mem_xx;

org $335b;
calculate:
	call stk_pntrs;

org $335e;
gen_ent_1:
	ld a, b;
	ld (breg),a;

org $3362;
gen_ent_2:
	exx;
	ex (sp), hl;
	exx;

org $3365;
re_entry:
	ld (stkend), de;
	exx;
	ld a, (hl);
	inc hl;

org $336c;
scan_ent:
	push hl;
	and a;
	jp p, first_3d;
	ld d, a;
	and %01100000;
	rrca;
	rrca;
	rrca;
	rrca;
	add a, 124;
	ld l, a;
	ld a, d;
	and %00011111;
	jr ent_table;

org $3380;
first_3d:
	cp 24;
	jr nc, double_a;
	exx;
	ld bc, $fffb;
	ld d, h;
	ld e, l;
	add hl, bc;
	exx;

org $338c;
double_a:
	rlca;
	ld l, a;

org $338e;
ent_table:
	ld de, tbl_addrs;
	ld h, 0;
	add hl, de;
	ld e, (hl);
	inc hl;
	ld d, (hl);
	ld hl, re_entry;
	ex (sp), hl;
	push de;
	exx;
	ld bc, (stkend_h);

org $33a1;
fp_delete:
	ret;

org $33a2;
fp_calc_2:
	pop af;
	ld a, (breg);
	exx;
	jr scan_ent;

org $33a9;
test_5_sp:
	push de;
	push hl;
	ld bc, $0005;
	call test_room;
	pop hl;
	pop de;
	ret;

org $33b4;
stack_num:
	ld de, (stkend);
	call move_fp;
	ld (stkend), de;
	ret;

org $33c0;
fp_duplicate:
move_fp:
	call test_5_sp;
	ldir;
	ret;

org $33c6;
fp_stk_data:
	ld h, d;
	ld l, e;

org $33c8;
stk_const:
	call test_5_sp;
	exx;
	push hl;
	exx;
	ex (sp), hl;
	push bc;
	ld a, (hl);
	and %11000000;
	rlca;
	rlca;
	ld c, a;
	inc c;
	ld a, (hl);
	and %00111111;
	jr nz, form_exp;
	inc hl;
	ld a, (hl);

org $33de;
form_exp:
	add a, 80;
	ld (de), a;
	ld a, 5;
	sub c;
	inc hl;
	inc de;
	ld b, 0;
	ldir;
	pop bc;
	ex (sp), hl;
	exx;
	pop hl;
	exx;
	ld b, a;
	xor a;

org $33f1;
stk_zeros:
	dec b;
	ret z;
	ld (de), a;
	inc de;
	jr stk_zeros;

org $33f7;
skip_cons:
	and a;

org $33f8;
skip_next:
	ret z;
	push af;
	push de;
	ld de, $0000;
	call stk_const;
	pop de;
	pop af;
	dec a;
	jr skip_next;

org $3406;
loc_mem:
	ld c, a;
	rlca;
	rlca;
	add a, c;
	ld c, a;
	ld b, 0;
	add hl, bc;
	ret;

org $340f;
fp_get_mem_xx:
	push de;
	ld hl, (mem);
	call loc_mem;
	call move_fp;
	pop hl;
	ret;

org $341b;
fp_stk_const_xx:
	ld h, d;
	ld l, e;
	exx;
	push hl;
	ld hl, cn_stk_zero;
	exx;
	call skip_cons;
	call stk_const;
	exx;
	pop hl;
	exx;
	ret;

org $342d;
fp_st_mem_xx:
	push hl;
	ex de, hl;
	ld hl, (mem);
	call loc_mem;
	ex de, hl;
	call move_fp;
	ex de, hl;
	pop hl;
	ret;

org $343c;
fp_exchange:
	ld b, 5;

org $343e;
swap_byte:
	ld a, (de);
	ld c, (hl);
	ex de, hl;
	ld (de), a;
	ld (hl), c;
	inc hl;
	inc de;
	djnz swap_byte;
	ex de, hl;
	ret;

org $3449;
fp_series_xx:
	ld b, a;
	call gen_ent_1;
	fmove();
	fadd();
	fst(0);
	fdel();
	fstk0();
	fst(2);

org $3453;
g_loop:
	fmove();
	fgt(0);
	fmul();
	fgt(2);
	fst(1);
	fsub();
	fce();
	call fp_stk_data;
	call gen_ent_2;
	fadd();
	fxch();
	fst(2);
	fdel();
	fdjnz(g_loop);
	fgt(1);
	fsub();
	fce();
	ret;

org $346a;
fp_abs:
	ld b, $ff;
	jr neg_test;

org $346e;
fp_negate:
	call test_zero;
	ret c;
	ld b, 0;

org $3474;
neg_test:
	ld a, (hl);
	and a;
	jr z, int_case;
	inc hl;
	ld a, b;
	and %10000000;
	or (hl);
	rla;
	ccf;
	rra;
	ld (hl), a;
	dec hl;
	ret;

org $3483;
int_case:
	push de;
	push hl;
	call int_fetch;
	pop hl;
	ld a, b;
	or c;
	cpl;
	ld c, a;
	call int_store;
	pop de;
	ret;

org $3492;
fp_sgn:
	call test_zero;
	ret c;
	push de;
	ld de, $0001;
	inc hl;
	rl (hl);
	dec hl;
	sbc a, a;
	ld c, a;
	call int_store;
	pop de;
	ret;

org $34a5;
fp_in:
	call find_int2;
	in a, (c);
	jr in_pk_stk;

org $34ac;
fp_peek:
	call find_int2;
	ld a, (bc);

org $34b0;
in_pk_stk:
	jp stack_a;

org $34b3;
fp_usr_no:
	call find_int2;
	ld hl, stack_bc;
	push hl;
	push bc;
	ret;

org $34bc;
fp_usr_str:
	call stk_fetch;
	dec bc;
	ld a, b;
	or c;
	jr nz, report_a;
	ld a, (de);
	call alpha;
	jr c, usr_range;
	sub 144;
	jr c, report_a;
	cp 21;
	jr nc, report_a;
	inc a;

org $34d3;
usr_range:
	dec a;
	add a, a;
	add a, a;
	add a, a;
	cp $a8;
	jr nc, report_a;
	ld bc, (udg);
	add a, c;
	ld c, a;
	jr nc, usr_stack;
	inc b;

org $34e4;
usr_stack:
	jp stack_bc;

org $34e7;
report_a:
	rst error;
	defb invalid_argument;

org $34e9;
test_zero:
	push hl;
	push bc;
	ld b, a;
	ld a, (hl);
	inc hl;
	or (hl);
	inc hl;
	or (hl);
	inc hl;
	or (hl);
	ld a, b;
	pop bc;
	pop hl;
	ret nz;
	scf;
	ret;

org $34f9;
fp_greater_0:
	call test_zero;
	ret c;
	ld a, $ff;
	jr sign_to_c;

org $3501;
fp_not:
	call test_zero;
	jr fp_0_div_1;

org $3506;
fp_less_0:
	xor a;

org $3507;
sign_to_c:
	inc hl;
	xor (hl);
	dec hl;
	rlca;

org $350b;
fp_0_div_1:
	push hl;
	ld a, 0;
	ld (hl), a;
	inc hl;
	ld (hl), a;
	inc hl;
	rla;
	ld (hl), a;
	rra;
	inc hl;
	ld (hl), a;
	inc hl;
	ld (hl), a;
	pop hl;
	ret;

org $351b;
fp_or:
	ex de, hl;
	call test_zero;
	ex de, hl;
	ret c;
	scf;
	jr fp_0_div_1;

org $3524;
fp_no_and_no:
	ex de, hl;
	call test_zero;
	ex de, hl;
	ret nc;
	and a;
	jr fp_0_div_1;

org $352d;
fp_str_and_no:
	ex de, hl;
	call test_zero;
	ex de, hl;
	ret nc;
	push de;
	dec de;
	xor a;
	ld (de), a;
	dec de;
	ld (de), a;
	pop de;
	ret;

org $353b;
fp_comparison:
	ld a, b;
	sub 8;
	bit 2, a;
	jr nz, ex_or_not;
	dec a;

org $3543;
ex_or_not:
	rrca;
	jr nc, nu_or_str;
	push af;
	push hl;
	call fp_exchange;
	pop de;
	ex de, hl;
	pop af;

org $354e;
nu_or_str:
	bit 2, a;
	jr nz, strings;
	rrca;
	push af;
	call fp_subtract;
	jr end_tests;

org $3559;
strings:
	rrca;
	push af;
	call stk_fetch;
	push de;
	push bc;
	call stk_fetch;
	pop hl;

org $3564;
byte_comp:
	ld a, h;
	or l;
	ex (sp), hl;
	ld a, b;
	jr nz, sec_plus;
	or c;

org $356b;
secnd_low:
	pop bc;
	jr z, both_null;
	pop af;
	ccf;
	jr str_test;

org $3572;
both_null:
	pop af;
	jr str_test;

org $3575;
sec_plus:
	or c;
	jr z, frst_less;
	ld a, (de);
	sub (hl);
	jr c, frst_less;
	jr nz, secnd_low;
	dec bc;
	inc de;
	inc hl;
	ex (sp), hl;
	dec hl;
	jr byte_comp;

org $3585;
frst_less:
	pop bc;
	pop af;
	and a;

org $3588;
str_test:
	push af;
	fwait();
	fstk0();
	fce();

org $358c;
end_tests:
	pop af;
	push af;
	call c, fp_not;
	pop af;
	push af;
	call nc, fp_greater_0;
	pop af;
	rrca;
	call nc, fp_not;
	ret;

org $359c;
fp_strs_add:
	call stk_fetch;
	push de;
	push bc;
	call stk_fetch;
	pop hl;
	push hl;
	push de;
	push bc;
	add hl, bc;
	ld b, h;
	ld c, l;
	rst bc_spaces;
	call stk_sto_str;
	pop bc;
	pop hl;
	ld a, b;
	or c;
	jr z, other_str;
	ldir;

org $35b7;
other_str:
	pop bc;
	pop hl;
	ld a, b;
	or c;
	jr z, stk_pntrs;
	ldir;

org $35bf;
stk_pntrs:
	ld hl, (stkend);
	ld de, $fffb;
	push hl;
	add hl, de;
	pop de;
	ret;

org $35c9;
fp_chr_str:
	call fp_to_a;
	jr c, report_bd;
	jr nz, report_bd;
	push af;
	ld bc, $0001;
	rst bc_spaces;
	pop af;
	ld (de), a;
	call stk_sto_str;
	ex de, hl;
	ret;

org $35dc;
report_bd:
	rst error;
	defb integer_out_of_range;

org $35de;
fp_val:
fp_val_str:
	ld hl, (ch_add);
	push hl;
	ld a, b;
	add a, 227;
	sbc a, a;
	push af;
	call stk_fetch;
	push de;
	inc bc;
	rst bc_spaces;
	pop hl;
	ld (ch_add), de;
	push de;
	ldir;
	ex de, hl;
	dec hl;
	ld (hl), ctrl_enter;
	res 7, (iy + _flags);
	call scanning;
	rst get_char;
	cp ctrl_enter;
	jr nz, v_rport_c;
	pop hl;
	pop af;
	xor (iy + _flags);
	and %01000000;

org $360c;
v_rport_c:
	jp nz, report_c;
	ld (ch_add), hl;
	set 7, (iy + _flags);
	call scanning;
	pop hl;
	ld (ch_add), hl;
	jr stk_pntrs;

org $361f;
fp_str_str:
	ld bc, $0001;
	rst bc_spaces;
	ld (k_cur), hl;
	push hl;
	ld hl, (curchl);
	push hl;
	ld a, $ff;
	call chan_open;
	call print_fp;
	pop hl;
	call chan_flag;
	pop de;
	ld hl, (k_cur);
	and a;
	sbc hl, de;
	ld b, h;
	ld c, l;
	call stk_sto_str;
	ex de, hl;
	ret;

org $3645;
fp_read_in:
	call find_int1;
	cp 16;
	jp nc, report_bb;
	ld hl, (curchl);
	push hl;
	call chan_open;
	call input_ad;
	ld bc, $0000;
	jr nc, r_i_store;
	inc c;
	rst bc_spaces;
	ld (de), a;

org $365f;
r_i_store:
	call stk_sto_str;
	pop hl;
	call chan_flag;
	jp stk_pntrs;

org $3669;
fp_code:
	call stk_fetch;
	ld a, b;
	or c;
	jr z, stk_code;
	ld a, (de);

org $3671;
stk_code:
	jp stack_a;

org $3674;
fp_len:
	call stk_fetch;
	jp stack_bc;

org $367a;
fp_dec_jr_nz:
	exx;
	push hl;
	ld hl, breg;
	dec (hl);
	pop hl;
	jr nz, jump_2;
	inc hl;
	exx;
	ret;

org $3686;
fp_jump:
	exx;

org $3687;
jump_2:
	ld e, (hl);
	ld a, e;
	rla;
	sbc a, a;
	ld d, a;
	add hl, de;
	exx;
	ret;

org $368f;
fp_jump_true:
	inc de;
	inc de;
	ld a, (de);
	dec de;
	dec de;
	and a;
	jr nz, fp_jump;
	exx;
	inc hl;
	exx;
	ret;

org $369b;
fp_end_calc:
	pop af;
	exx;
	ex (sp), hl;
	exx;
	ret;

org $36a0;
fp_n_mod_m:
	fwait();
	fst(0);
	fdel();
	fmove();
	fgt(0);
	fdiv();
	fint();
	fgt(0);
	fxch();
	fst(0);
	fmul();
	fsub();
	fgt(0);
	fce();
	ret;

org $36af;
fp_int:
	fwait();
	fmove();
	fcp(_lz);
	fjpt(x_neg);
	ftrn();
	fce();
	ret;

org $36b7;
x_neg:
	fmove();
	ftrn();
	fst(0);
	fsub();
	fgt(0);
	fxch();
	fnot();
	fjpt(exit);
	fstk1();
	fsub();

org $36c2;
exit:
	fce();
	ret;

org $36c4;
fp_exp:
	fwait();
	frstk();
	fstk();
	defb $f1, $38, $aa, $3b, $29;
	fmul();
	fmove();
	fint();
	fst(3);
	fsub();
	fmove();
	fadd();
	fstk1();
	fsub();
	defb $88;
	defb $13, $36;
	defb $58, $65, $66;
	defb $9d, $78, $65, $40;
	defb $a2, $60, $32, $c9;
	defb $e7, $21, $f7, $af, $24;
	defb $eb, $2f, $b0, $b0, $14;
	defb $ee, $7e, $bb, $94, $58;
	defb $f1, $3a, $7e, $f8, $cf;
	fgt(3);
	fce();
	call fp_to_a;
	jr nz, n_negtv;
	jr c, report_6b;
	add a, (hl);
	jr nc, result_ok;

org $3703;
report_6b:
	rst error;
	defb number_too_big;

org $3705;
n_negtv:
	jr c, rslt_zero;
	sub (hl);
	jr nc, rslt_zero;
	neg;

org $370c;
result_ok:
	ld (hl), a;
	ret;

org $370e;
rslt_zero:
	fwait();
	fdel();
	fstk0();
	fce();
	ret;

org $3713;
fp_ln:
	fwait();
	frstk();
	fmove();
	fcp(_gz);
	fjpt(valid);
	fce();

org $371a;
report_ab:
	rst error;
	defb invalid_argument;

org $371c;
valid:
	fstk0();
	fdel();
	fce();
	ld a, (hl);
	ld (hl), $80;
	call stack_a;
	fwait();
	fstk();
	defb $38, $00;
	fsub();
	fxch();
	fmove();
	fstk();
	defb $f0, $4c, $cc, $cc, $cd;
	fsub();
	fcp(_gz);
	fjpt(gre_8);
	fxch();
	fstk1();
	fsub();
	fxch();
	fce();
	inc (hl);
	fwait();

org $373d;
gre_8:
	fxch();
	fstk();
	defb $f0, $31, $72, $17, $f8;
	fmul();
	fxch();
	fstkhalf();
	fsub();
	fstkhalf();
	fsub();
	fmove();
	fstk();
	defb $32, $20;
	fmul();
	fstkhalf();
	fsub();
	defb $8c;
	defb $11, $ac;
	defb $14, $09;
	defb $56, $da, $a5;
	defb $59, $30, $c5;
	defb $5c, $90, $aa;
	defb $9e, $70, $6f, $61;
	defb $a1, $cb, $da, $96;
	defb $a4, $31, $9f, $b4;
	defb $e7, $a0, $fe, $5c, $fc;
	defb $ea, $1b, $43, $ca, $36;
	defb $ed, $a7, $9c, $7e, $5e;
	defb $f0, $6e, $23, $80, $93;
	fmul();
	fadd();
	fce();
	ret;

org $3783;
fp_get_argt:
	fwait();
	frstk();
	fstk();
	defb $ee, $22, $f9, $83, $6e;
	fmul();
	fmove();
	fstkhalf();
	fadd();
	fint();
	fsub();
	fmove();
	fadd();
	fmove();
	fadd();
	fmove();
	fabs();
	fstk1();
	fsub();
	fmove();
	fcp(_gz);
	fst(0);
	fjpt(zplus);
	fdel();
	fce();
	ret;

org $37a1;
zplus:
	fstk1();
	fsub();
	fxch();
	fcp(_lz);
	fjpt(yneg);
	fneg();

org $37a8;
yneg:
	fce();
	ret;

org $37aa;
fp_cos:
	fwait();
	fget();
	fabs();
	fstk1();
	fsub();
	fgt(0);
	fjpt(c_ent);
	fneg();
	fjp(c_ent);

org $37b5;
fp_sin:
	fwait();
	fget();

org $37b7;
c_ent:
	fmove();
	fmove();
	fmul();
	fmove();
	fadd();
	fstk1();
	fsub();
	defb $86;
	defb $14, $e6;
	defb $5c, $1f, $0b;
	defb $a3, $8f, $38, $ee;
	defb $e9, $15, $63, $bb, $23;
	defb $ee, $92, $0d, $cd, $ed;
	defb $f1, $23, $5d, $1b, $ea;
	fmul();
	fce();
	ret;

org $37da;
fp_tan:
	fwait();
	fmove();
	fsin();
	fxch();
	fcos();
	fdiv();
	fce();
	ret;

org $37e2;
fp_atn:
	call fp_re_stack;
	ld a, (hl);
	cp $81;
	jr c, small;
	fwait();
	fstk1();
	fneg();
	fxch();
	fdiv();
	fmove();
	fcp(_lz);
	fstkhalfpi();
	fxch();
	fjpt(cases);
	fneg();
	fjp(cases);

org $37f8;
small:
	fwait();
	fstk0();

org $37fa;
cases:
	fxch();
	fmove();
	fmove();
	fmul();
	fmove();
	fadd();
	fstk1();
	fsub();
	defb $8c;
	defb $10, $b2;
	defb $13, $0e;
	defb $55, $e4, $8d;
	defb $58, $39, $bc;
	defb $5b, $98, $fd;
	defb $9e, $00, $36, $75;
	defb $a0, $db, $e8, $b4;
	defb $63, $42, $c4;
	defb $e6, $b5, $09, $36, $be;
	defb $e9, $36, $73, $1b, $5d;
	defb $ec, $d8, $de, $63, $be;
	defb $f0, $61, $a1, $b3, $0c;
	fmul();
	fadd();
	fce();
	ret;

org $3833;
fp_asn:
	fwait();
	fmove();
	fmove();
	fmul();
	fstk1();
	fsub();
	fneg();
	fsqrt();
	fstk1();
	fadd();
	fdiv();
	fatan();
	fmove();
	fadd();
	fce();
	ret;

org $3843;
fp_acs:
	fwait();
	fasin();
	fstkhalfpi();
	fsub();
	fneg();
	fce();
	ret;

org $384a;
fp_sqr:
	fwait();
	fmove();
	fnot();
	fjpt(last);
	fstkhalf();
	fce();

org $3851;
fp_to_power:
	fwait();
	fxch();
	fmove();
	fnot();
	fjpt(xis0);
	flogn();
	fmul();
	fce();
	jp fp_exp;

org $385d;
xis0:
	fdel();
	fmove();
	fnot();
	fjpt(one);
	fstk0();
	fxch();
	fcp(_gz);
	fjpt(last);
	fstk1();
	fxch();
	fdiv();

org $386a;
one:
	fdel();
	fstk1();

org $386c;
last:
	fce();
	ret;

org $3c00;
font:
	import_bin "font.bin", $3c00, $400

; Various output options;

	output_bin "../emu/48.rom", 0,$4000 ; Raw binary;
;	output_intel "rom.hex",0,$4000 ; Intel Hex;
;	output_srec "rom.s", 0,$4000 ; Motorola S-record;
;	output_db "rom.db", 0,$4000 ; DB statements for inclusion in sources;
;	output_unit "rom.pas","Spectrum_ROM","Rom_Code","// Assembled " + TIMESTR,0,$4000 ; A Delphi UNIT file.;

